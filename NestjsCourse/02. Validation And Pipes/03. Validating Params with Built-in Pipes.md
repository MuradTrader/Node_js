### Общий контекст: Практическое применение ParseIntPipe

Автор начинает использовать первый встроенный пайп — `ParseIntPipe` — для решения проблемы преобразования строк в числа, которую мы обсуждали ранее.

---

### Часть 1: Введение во встроенные пайпы

**Что говорит автор:**
Автор напоминает, что существует 9 встроенных пайпов, которые можно импортировать из `@nestjs/common`. Он фокусируется на тех, которые можно использовать напрямую с параметрами, не создавая кастомные файлы.

**Подробное объяснение:**

- **Built-in Pipes (Встроенные пайпы):** Это готовые решения для самых распространенных задач валидации и трансформации. Не нужно изобретать велосипед для базовых преобразований.
- **Отличие ValidationPipe:** Автор специально отмечает, что `ValidationPipe` — это более мощный и сложный инструмент, который требует создания DTO (Data Transfer Objects) и использования декораторов из библиотеки `class-validator`. Его мы рассмотрим позже.
- **Принцип обучения:** Автор говорит, что если мы поймем, как работает `ParseIntPipe` и `DefaultValuePipe` (который будет дальше), то сможем легко разобраться и с остальными (например, `ParseBoolPipe`, `ParseUUIDPipe` и т.д.), так как принцип их применения одинаков.

---

### Часть 2: Что такое ParseIntPipe и как он работает

**Что говорит автор:**
`ParseIntPipe` — это пайп, который выполняет две функции одновременно: **трансформацию** и **валидацию**.

**Подробное объяснение:**

1.  **Трансформация (Transformation):**

    - **Задача:** Преобразует входящее значение (которое всегда строка) в целое число (`integer`).
    - **Пример:** `"1234"` → `1234`

2.  **Валидация (Validation):**
    - **Задача:** Проверяет, можно ли вообще преобразовать переданное значение в целое число.
    - **Если нельзя** (например, передали `"abc"`, `"123.45"` или `"12a3"`), пайп автоматически **выбрасывает исключение**.
    - **Результат исключения:** NestJS ловит это исключение через механизм Exception Filters (который мы обсуждали) и автоматически отправляет клиенту ответ с HTTP-статусом `400 Bad Request` и сообщением об ошибке.

**Ключевой вывод:** Всего одной строчкой кода мы получаем и преобразование типа, и надежную валидацию. Это избавляет от написания рутинных проверок в каждом контроллере.

---

### Часть 3: Практическая реализация в коде

**Что говорит автор:**
Автор показывает, как именно подключить и использовать `ParseIntPipe` в методе контроллера.

**Подробное объяснение шагов:**

1.  **Импорт:**

    ```typescript
    import { ParseIntPipe } from "@nestjs/common";
    ```

    Это стандартный импорт из пакета NestJS.

2.  **Применение пайпа:**
    Автор меняет код параметра `id`:

    ```typescript
    // БЫЛО (без пайпа):
    @Param('id') id: string

    // СТАЛО (с пайпом):
    @Param('id', ParseIntPipe) id: number
    ```

    - **Синтаксис:** Пайп передается **вторым аргументом** в декоратор (`@Param`, `@Query`, `@Body` и т.д.). Можно передавать несколько пайпов через запятую, они будут выполнены последовательно.
    - **`id: number`:** Обратите внимание, что теперь мы меняем тип TypeScript с `string` на `number`. Это возможно, потому что `ParseIntPipe` гарантирует, что к моменту выполнения кода контроллера `id` уже будет числом (либо запрос будет отклонен с ошибкой).

3.  **Демонстрация успешного сценария:**

    - Автор отправляет запрос `GET /users/1234`.
    - В консоли мы видим: `1234 number`.
    - **Это доказывает,** что пайп сработал: строка `"1234"` была успешно преобразована в число `1234`.

4.  **Демонстрация сценария с ошибкой:**
    - Автор отправляет запрос `GET /users/abc`.
    - Сервер автоматически отвечает статусом `400 Bad Request` с сообщением, что валидация не пройдена.
    - **Это доказывает,** что валидационная часть пайпа тоже работает. Код контроллера даже не начинает выполняться.

---

### Часть 4: Важное ограничение и обнаруженная проблема

**Что говорит автор:**
Автор пытается сделать параметр `id` опциональным, добавляя символ `?` в его объявление (`id?`), но это приводит к неожиданной ошибке валидации, даже когда ID не передается.

**Подробное объяснение проблемы:**

- **Ожидание:** Мы хотим, чтобы эндпоинт `GET /users` (без ID) работал и возвращал список пользователей, а `GET /users/123` возвращал одного пользователя.
- **Реальность:** При запросе `GET /users` пайп `ParseIntPipe` все равно запускается и пытается преобразовать `undefined` (так как ID не передан) в число. Это невозможно, поэтому пайп выбрасывает ошибку `400 Bad Request`.

- **Причина проблемы:** Такое поведение характерно для всех "Parse-пайпов" (`ParseIntPipe`, `ParseBoolPipe` и др.). Они разработаны с предположением, что параметр, к которому они применяются, **является обязательным**. Если значения нет — это считается ошибкой валидации.

- **Решение (которое будет позже):** Автор упоминает, что эту проблему можно будет элегантно решить с помощью **DTO (Data Transfer Objects)** и `ValidationPipe`, где настройки валидации являются более гибкими. Пока же он предлагает оставить параметр обязательным.

---

### Итоговый вывод от вашего "профессионального разработчика":

На этом уроке мы прошли crucial (ключевой) этап — начали применять пайпы на практике.

1.  **Мощь фреймворка:** Вы увидели, как одной строкой кода (`ParseIntPipe`) можно заменить кучу рутинных проверок `if (isNaN(id))...`. Это сила NestJS и его философии "convention over configuration" (соглашения вместо конфигураций).

2.  **Правильное применение:** Вы научились синтаксису подключения пайпов к декораторам параметров. Это стандартный паттерн, который используется для `@Param()`, `@Query()` и `@Body()`.

3.  **Осознание ограничений:** Вы столкнулись с первым нюансом фреймворка — "Parse-пайпы" не работают с опциональными параметрами "из коробки". Это важное знание, которое поможет вам избежать ошибок в будущем и понимать, когда нужно использовать более сложные инструменты вроде DTO.

4.  **Движение вперед:** Автор четко обозначил дорожную карту: мы разобрались с `id`, в следующем видео займемся `limit` и `page`, а затем перейдем к DTO для решения проблемы опциональности.
