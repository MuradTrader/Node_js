## Подробное объяснение интеграции JWT в NestJS приложение

### **Контекст и цель**

**Текущее состояние:**

- Метод `signIn` в `SignInProvider` возвращает `true`
- Нужно заменить возвращаемое значение на JWT токен

**Цель видео:**

- Интеграция JWT сервиса в приложение
- Настройка конфигурации JWT
- Подготовка к генерации токенов

---

### **Шаг 1: Установка NestJS JWT пакета**

**Команда установки:**

```bash
npm install @nestjs/jwt@10.2.0
```

**Почему именно эта версия:**

- Автор использует конкретную версию для совместимости
- 10.2.0 - стабильная версия на момент записи курса

---

### **Шаг 2: Настройка environment variables**

**Добавление в `.env.development`:**

```env
JWT_SECRET=your-super-secret-key-here
TOKEN_AUDIENCE=http://localhost:3000
TOKEN_ISSUER=http://localhost:3000
JWT_ACCESS_TOKEN_TTL=3600
```

**Объяснение каждой переменной:**

#### **JWT_SECRET**

- Секретный ключ для подписи JWT
- Должен быть длинным и случайным
- Чем длиннее ключ, тем сложнее взломать подпись

#### **TOKEN_AUDIENCE**

- URL/домен, для которого предназначен токен
- Защита от использования токена на другом домене
- В development: `http://localhost:3000`

#### **TOKEN_ISSUER**

- Домен, который выпустил токен
- Идентифицирует издателя токена
- В development: `http://localhost:3000`

#### **JWT_ACCESS_TOKEN_TTL**

- Время жизни токена в секундах
- 3600 секунд = 1 час
- Короткое TTL улучшает безопасность

---

### **Шаг 3: Создание JWT конфигурации**

**Структура файлов:**

```
src/auth/
└── config/
    └── jwt.config.ts
```

**Реализация `jwt.config.ts`:**

```typescript
import { registerAs } from "@nestjs/config";

export default registerAs("jwt", () => ({
  secret: process.env.JWT_SECRET,
  audience: process.env.TOKEN_AUDIENCE,
  issuer: process.env.TOKEN_ISSUER,
  accessTokenTtl: parseInt(process.env.JWT_ACCESS_TOKEN_TTL ?? "3600", 10),
}));
```

**Детальное объяснение `registerAs`:**

**Параметры:**

- `'jwt'` - namespace для конфигурации
- Функция, возвращающая объект конфигурации

**Особенности реализации:**

- `process.env.JWT_ACCESS_TOKEN_TTL ?? '3600'` - fallback значение
- `parseInt(..., 10)` - преобразование строки в число (десятичная система)
- Базовая конфигурация без сложной валидации

---

### **Шаг 4: Настройка AuthModule**

**Импорты в `auth.module.ts`:**

```typescript
import { ConfigModule } from '@nestjs/config';
import { JwtModule } from '@nestjs/jwt';
import jwtConfig from './config/jwt.config';

@Module({
  imports: [
    // Загрузка JWT конфигурации
    ConfigModule.forFeature(jwtConfig),

    // Асинхронная регистрация JWT модуля
    JwtModule.registerAsync(jwtConfig.asProvider()),
  ],
})
```

**Детальное объяснение настройки:**

#### **ConfigModule.forFeature(jwtConfig)**

- Делает JWT конфигурацию доступной в AuthModule
- Конфигурация загружается только когда нужна
- Не загромождает глобальную конфигурацию

#### **JwtModule.registerAsync(jwtConfig.asProvider())**

- Асинхронная регистрация JWT модуля
- `jwtConfig.asProvider()` - создает провайдер для конфигурации
- Позволяет использовать environment variables в JWT модуле

**Что происходит внутри `asProvider()`:**

```typescript
// Псевдокод того, что делает asProvider()
jwtConfig.asProvider() = {
  provide: "CONFIGURATION(jwt)",
  useFactory: async (configService: ConfigService) => {
    return configService.get("jwt");
  },
  inject: [ConfigService],
};
```

---

### **Шаг 5: Архитектура JWT модуля**

**Как работает dependency injection:**

```
AuthModule
    ↓ imports
JwtModule (from @nestjs/jwt)
    ↓ uses
JwtService (инжектируется в провайдеры)
    ↓ использует
jwtConfig (через ConfigService)
```

**Преимущества асинхронной настройки:**

- Конфигурация загружается до инициализации JwtModule
- Можно использовать асинхронные источники (база данных, удаленные сервисы)
- Более гибкая настройка

---

### **Шаг 6: Проверка работоспособности**

**Индикаторы успеха:**

- Приложение запускается без ошибок
- JwtModule успешно загружен
- Конфигурация доступна через ConfigService

---

### **Шаг 7: Подготовка к использованию JwtService**

**Что будет в следующем видео:**

- Инжект JwtService в SignInProvider
- Генерация JWT токена после успешной аутентификации
- Замена возвращаемого значения `true` на токен

**Пример будущего кода:**

```typescript
// В SignInProvider
constructor(
  private readonly jwtService: JwtService,
) {}

async signIn(signInDto: SignInDto): Promise<string> {
  // ... аутентификация пользователя ...

  // Генерация JWT токена
  const token = await this.jwtService.signAsync({
    sub: user.id,
    email: user.email,
  });

  return token;
}
```

---

### **Технические детали реализации**

#### **JwtModule.registerAsync options**

**Полная сигнатура метода:**

```typescript
JwtModule.registerAsync({
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) => ({
    secret: configService.get("jwt.secret"),
    signOptions: {
      audience: configService.get("jwt.audience"),
      issuer: configService.get("jwt.issuer"),
      expiresIn: configService.get("jwt.accessTokenTtl"),
    },
  }),
  inject: [ConfigService],
});
```

**Почему автор использует `jwtConfig.asProvider()`:**

- Сокращает boilerplate код
- Использует уже существующую конфигурацию
- Единообразие в кодовой базе

---

### **Best Practices от автора**

#### **Безопасность:**

1. **Секретный ключ:**

   - Длинный и случайный
   - Хранится в environment variables
   - Разный для development/production

2. **Время жизни токена:**
   - Короткое для access token (1 час)
   - В будущем: refresh tokens для продления сессии

#### **Архитектура:**

1. **Модульная конфигурация:**

   - Каждый модуль управляет своей конфигурацией
   - Четкое разделение ответственности

2. **Асинхронная инициализация:**
   - Позволяет использовать асинхронные источники данных
   - Более надежная загрузка приложения

---

### **Поток данных при генерации токена**

```
SignInProvider.signIn()
    ↓
Успешная аутентификация
    ↓
JwtService.signAsync(payload)
    ↓
Использование конфигурации из jwtConfig
    ↓
Создание JWT: header + payload + signature
    ↓
Возврат токена клиенту
```

---

### **Дизайн решения**

**Почему отдельный config файл:**

- Изоляция JWT конфигурации
- Легко находить и изменять настройки
- Возможность переиспользования в других модулях

**Почему асинхронная регистрация:**

- Конфигурация может загружаться асинхронно
- Поддержка различных источников конфигурации
- Соответствие принципам NestJS

---

### **Готовность к production**

**Что уже настроено:**

- ✅ Безопасное хранение секретов
- ✅ Конфигурируемое время жизни токенов
- ✅ Проверка audience и issuer
- ✅ Модульная архитектура

**Что нужно добавить для production:**

- Более строгая валидация конфигурации
- Rotating secrets
- Мониторинг истекающих токенов
- Refresh token mechanism

Автор успешно интегрировал JWT инфраструктуру в приложение, подготовив фундамент для генерации и верификации токенов. Архитектура следует best practices NestJS и обеспечивает безопасность и масштабируемость.
