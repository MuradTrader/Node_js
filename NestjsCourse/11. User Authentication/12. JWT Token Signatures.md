## Подробное объяснение тестирования и анализа JWT токена

### **Контекст тестирования**

**Цель видео:**

- Проверить работу JWT генерации на практике
- Проанализировать структуру созданного токена
- Понять механизм безопасности JWT

---

### **Шаг 1: Практическое тестирование endpoint'а**

**Процесс тестирования:**

1. **Открытие HTTP файла для тестирования:**

   ```
   src/auth/http/sign-in.endpoints.http
   ```

2. **Отправка запроса на вход:**

   ```http
   POST http://localhost:3000/auth/sign-in
   Content-Type: application/json

   {
     "email": "mark@example.com",
   "password": "password123hash"
   }
   ```

3. **Ожидаемый результат:**
   - Статус код: `200 OK`
   - Тело ответа содержит `accessToken` вместо `true`

**Фактический результат:**

```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---

### **Шаг 2: Анализ токена на jwt.io**

**Процесс анализа:**

1. **Копирование токена** из ответа
2. **Вставка на jwt.io** для декодирования
3. **Анализ структуры токена**

**Декодированная структура токена:**

#### **Header:**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### **Payload:**

```json
{
  "sub": 10,
  "email": "mark@example.com",
  "iat": 1616239022,
  "exp": 1616242622,
  "aud": "http://localhost:3000",
  "iss": "http://localhost:3000"
}
```

---

### **Шаг 3: Детальный анализ полей payload**

#### **sub (Subject) - 10**

- Идентификатор пользователя Mark в базе данных
- Проверка в PgAdmin подтверждает: пользователь Mark имеет ID = 10
- Используется для идентификации пользователя в системе

#### **email - "mark@example.com"**

- Кастомное поле, добавленное разработчиком
- Не чувствительная информация, безопасна для публичного доступа

#### **iat (Issued At) - 1616239022**

- Время создания токена в Unix timestamp
- Рассчитывается автоматически при создании токена
- Текущее время на момент генерации

#### **exp (Expiration) - 1616242622**

- Время истечения токена в Unix timestamp
- Рассчитывается: `iat + 3600 секунд`
- Разница между `exp` и `iat` = 3600 секунд (1 час)

#### **aud (Audience) - "http://localhost:3000"**

- Аудитория токена - домен, для которого предназначен токен
- Защита от использования токена на другом домене

#### **iss (Issuer) - "http://localhost:3000"**

- Издатель токена - домен, который выпустил токен
- Проверка подлинности источника токена

---

### **Шаг 4: Демонстрация безопасности подписи**

**Эксперимент с изменением токена:**

1. **Изменение payload:**

   - Меняем `"sub": 10` на `"sub": 9`
   - На сайте jwt.io видим мгновенное изменение подписи

2. **Механизм защиты:**

   ```
   Исходный токен: header.payload.correct_signature
   Измененный токен: header.modified_payload.different_signature
   ```

3. **Проверка на сервере:**
   - Сервер вычисляет ожидаемую подпись с оригинальным secret
   - Сравнивает с полученной подписью
   - При несовпадении - токен отвергается

**Технический процесс проверки:**

```typescript
function verifyToken(token, secret) {
  const [header, payload, signature] = token.split(".");

  // Вычисляем ожидаемую подпись
  const expectedSignature = createSignature(header, payload, secret);

  // Сравниваем с полученной подписью
  if (signature !== expectedSignature) {
    throw new Error("Invalid signature");
  }

  return true;
}
```

---

### **Шаг 5: Важность времени жизни токена**

**Текущая настройка:**

- `expiresIn: 3600` секунд (1 час)
- Короткое время жизни повышает безопасность

**Преимущества короткого TTL:**

1. **Ограничение ущерба** при компрометации токена
2. **Принудительное обновление** учетных данных
3. **Снижение риска** replay-атак

**Проблемы короткого TTL:**

- Неудобство для пользователей
- Необходимость частого повторного входа

**Решение: Refresh Tokens**

- Долгоживущие refresh tokens для получения новых access tokens
- Access tokens с коротким временем жизни
- Баланс между безопасностью и удобством

---

### **Шаг 6: Анализ уязвимостей и защита**

#### **Что защищено:**

✅ **Целостность данных** - подпись гарантирует неизменность  
✅ **Аутентичность источника** - проверка issuer  
✅ **Целевое использование** - проверка audience  
✅ **Актуальность** - проверка expiration time

#### **Что не защищено:**

❌ **Конфиденциальность payload** - данные видны всем  
❌ **Кража токена** - если токен украден, им можно пользоваться до истечения

#### **Меры защиты:**

1. **HTTPS** для передачи токенов
2. **HttpOnly cookies** для хранения на клиенте
3. **Short expiration** для минимизации ущерба
4. **Token blacklisting** для отзыва скомпрометированных токенов

---

### **Шаг 7: Практические выводы для разработки**

#### **Что работает правильно:**

- Генерация токена с правильными claims
- Настройка audience и issuer
- Корректное время жизни
- Механизм подписи функционирует

#### **Что нужно помнить:**

1. **Never store sensitive data in payload**
2. **Always validate audience and issuer**
3. **Use short expiration times**
4. **Implement proper token storage on client**
5. **Plan for token refresh mechanism**

---

### **Шаг 8: Визуализация процесса аутентификации**

```
Клиент → [Email/Password] → Сервер
    ↓
Сервер → [Проверка учетных данных] → База данных
    ↓
Сервер → [Генерация JWT] → Секретный ключ
    ↓
Сервер → [JWT токен] → Клиент
    ↓
Клиент → [JWT в заголовках] → Защищенный endpoint
    ↓
Сервер → [Проверка подписи] → Секретный ключ
    ↓
Сервер → [Доступ к данным] → Клиент
```

---

### **Шаг 9: Подготовка к следующим темам**

**Что автор упоминает о будущем:**

- Реализация refresh tokens
- Механизм автоматического обновления токенов
- Баланс между безопасностью и пользовательским опытом

**Текущий статус безопасности:**

```
✅ Базовая JWT аутентификация работает
✅ Токены генерируются правильно
✅ Механизм подписи обеспечивает целостность
⚠️  Нужна реализация refresh tokens для удобства
⚠️  Нужна защита маршрутов с помощью guards
```

Автор успешно продемонстрировал работу JWT системы, показал на практике как создается и проверяется токен, и объяснил фундаментальные принципы безопасности JWT. Это создает прочную основу для реализации защиты API endpoints в следующих видео.
