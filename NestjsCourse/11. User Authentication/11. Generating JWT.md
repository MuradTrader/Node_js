## Подробное объяснение реализации генерации JWT токена

### **Контекст и цель**

**Текущее состояние:**

- JWT модуль и конфигурация успешно интегрированы в AuthModule
- Метод `signIn` в `SignInProvider` возвращает `true`
- Нужно заменить возвращаемое значение на JWT токен

---

### **Шаг 1: Подготовка SignInProvider**

**Удаление временного решения:**

```typescript
// Было:
return true;

// Стало:
// Будем возвращать JWT токен
```

---

### **Шаг 2: Dependency Injection в SignInProvider**

#### **Инжект JwtService**

```typescript
constructor(
  // ... существующие зависимости ...

  // Инжект JwtService
  private readonly jwtService: JwtService,

  // ... другие зависимости ...
)
```

**Объяснение JwtService:**

- Сервис из пакета `@nestjs/jwt`
- Предоставляет методы для работы с JWT токенами
- Автоматически настраивается через JwtModule

#### **Инжект JWT конфигурации**

```typescript
constructor(
  // ... существующие зависимости ...

  // Инжект JWT конфигурации
  @Inject(jwtConfig.KEY)
  private readonly jwtConfiguration: ConfigType<typeof jwtConfig>,

  // ... другие зависимости ...
)
```

**Детальное объяснение инжекта конфигурации:**

**Компоненты:**

- `@Inject(jwtConfig.KEY)` - декоратор для инжекта по ключу
- `jwtConfig.KEY` - уникальный идентификатор конфигурации
- `ConfigType<typeof jwtConfig>` - TypeScript тип для типизации

**Что происходит:**

- NestJS находит конфигурацию по ключу `jwtConfig.KEY`
- Предоставляет объект конфигурации с типами TypeScript
- Все свойства доступны с автодополнением

---

### **Шаг 3: Генерация JWT токена**

#### **Использование JwtService.signAsync()**

```typescript
const accessToken = await this.jwtService.signAsync(
  {
    sub: user.id, // Subject - идентификатор пользователя
    email: user.email, // Дополнительные данные
  },
  {
    audience: this.jwtConfiguration.audience,
    issuer: this.jwtConfiguration.issuer,
    secret: this.jwtConfiguration.secret,
    expiresIn: this.jwtConfiguration.accessTokenTtl,
  }
);
```

**Детальное объяснение параметров:**

#### **Параметр 1: Payload (полезная нагрузка)**

```typescript
{
  sub: user.id,    // Стандартное поле JWT - subject
  email: user.email // Кастомное поле
}
```

**Стандартные поля JWT (claims):**

- `sub` (subject) - идентификатор пользователя
- `exp` (expiration) - время истечения (добавляется автоматически)
- `iat` (issued at) - время создания (добавляется автоматически)
- `aud` (audience) - аудитория (указывается в options)
- `iss` (issuer) - издатель (указывается в options)

**Рекомендации по payload:**

- Используйте стандартные поля когда возможно
- Не включайте чувствительные данные
- Минимальный набор для идентификации пользователя

#### **Параметр 2: Options (опции подписи)**

```typescript
{
  audience: this.jwtConfiguration.audience,
  issuer: this.jwtConfiguration.issuer,
  secret: this.jwtConfiguration.secret,
  expiresIn: this.jwtConfiguration.accessTokenTtl,
}
```

**Объяснение каждой опции:**

**audience:**

- Проверка, что токен используется правильным получателем
- Защита от использования токена на другом домене
- Значение: `http://localhost:3000`

**issuer:**

- Идентификатор того, кто выпустил токен
- Проверка, что токен выпущен нашим сервером
- Значение: `http://localhost:3000`

**secret:**

- Секретный ключ для подписи
- Должен совпадать с ключом для верификации
- Берется из environment variables

**expiresIn:**

- Время жизни токена в секундах
- 3600 секунд = 1 час
- Автоматически добавляет поле `exp` в payload

---

### **Шаг 4: Возврат результата**

```typescript
return { accessToken };
```

**Почему объект, а не строка:**

- Легко расширить в будущем (добавить refresh token, тип токена и т.д.)
- Соответствует REST best practices
- Клиент ожидает структурированный ответ

**Пример полного ответа:**

```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---

### **Полный код метода signIn**

```typescript
public async signIn(signInDto: SignInDto): Promise<{ accessToken: string }> {
  // Шаг 1: Найти пользователя по email
  const user = await this.usersService.findOneByEmail(signInDto.email);

  // Шаг 2: Сравнить пароли
  let isEqual = false;
  try {
    isEqual = await this.hashingProvider.comparePassword(
      signInDto.password,
      user.password
    );
  } catch (error) {
    throw new RequestTimeoutException('Could not compare passwords', {
      description: error.message,
    });
  }

  if (!isEqual) {
    throw new UnauthorizedException('Incorrect password');
  }

  // Шаг 3: Генерация JWT токена
  const accessToken = await this.jwtService.signAsync(
    {
      sub: user.id,      // Subject - идентификатор пользователя
      email: user.email, // Email пользователя
    },
    {
      audience: this.jwtConfiguration.audience,
      issuer: this.jwtConfiguration.issuer,
      secret: this.jwtConfiguration.secret,
      expiresIn: this.jwtConfiguration.accessTokenTtl,
    }
  );

  // Шаг 4: Возврат токена
  return { accessToken };
}
```

---

### **Технические детали реализации**

#### **Типы возвращаемых значений**

**Сигнатура метода:**

```typescript
public async signIn(signInDto: SignInDto): Promise<{ accessToken: string }>
```

**Объяснение:**

- Возвращает Promise, который резолвится в объект
- Объект содержит свойство `accessToken` типа string
- Явная типизация помогает TypeScript и автодополнению

#### **JwtService.signAsync() метод**

**Что происходит внутри:**

1. Создание header с алгоритмом и типом
2. Формирование payload с добавлением стандартных claims
3. Создание подписи с использованием secret
4. Кодирование всех частей в Base64Url
5. Объединение в итоговую строку

**Автоматически добавляемые поля:**

- `iat` (issued at) - время создания токена
- `exp` (expiration) - время истечения (рассчитывается из expiresIn)

---

### **Поток данных при генерации токена**

```
SignInProvider.signIn()
    ↓
Успешная аутентификация пользователя
    ↓
JwtService.signAsync()
    ↓
Создание header: { alg: "HS256", typ: "JWT" }
    ↓
Создание payload: { sub, email, iat, exp }
    ↓
Создание подписи: HMACSHA256(base64Url(header) + "." + base64Url(payload), secret)
    ↓
Кодирование всех частей в Base64Url
    ↓
Объединение: header.payload.signature
    ↓
Возврат accessToken клиенту
```

---

### **Security Considerations**

#### **Безопасность payload:**

- Email включен в payload, но это не чувствительные данные
- Не включаются пароли, персональные данные, права доступа
- Для дополнительных данных использовать базу данных

#### **Время жизни токена:**

- 1 час - разумный компромисс между безопасностью и удобством
- Короткое время уменьшает риск использования украденного токена
- В будущем можно добавить refresh tokens

#### **Проверка audience и issuer:**

- Защита от использования токена в неправильном контексте
- Предотвращает атаки подмены домена

---

### **Интеграция с остальной системой**

**Обновление AuthService:**

```typescript
// AuthService теперь возвращает объект с токеном
public async signIn(signInDto: SignInDto): Promise<{ accessToken: string }> {
  return this.signInProvider.signIn(signInDto);
}
```

**Обновление AuthController:**

```typescript
// AuthController возвращает тот же объект
@Post('sign-in')
@HttpCode(HttpStatus.OK)
public async signIn(@Body() signInDto: SignInDto): Promise<{ accessToken: string }> {
  return this.authService.signIn(signInDto);
}
```

---

### **Результат работы**

**Успешный ответ:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOjEsImVtYWlsIjoibWFya0BleGFtcGxlLmNvbSIsImlhdCI6MTYxNjIzOTAyMiwiZXhwIjoxNjE2MjQyNjIyLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

**Структура декодированного токена:**

```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": 1,
    "email": "mark@example.com",
    "iat": 1616239022,
    "exp": 1616242622,
    "aud": "http://localhost:3000",
    "iss": "http://localhost:3000"
  },
  "signature": "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

Автор успешно реализовал генерацию JWT токенов после аутентификации пользователя. Токен содержит необходимую информацию для идентификации пользователя и настроен с учетом лучших практик безопасности. В следующем видео будет тестирование этой функциональности и, возможно, начало работы над защитой маршрутов с помощью JWT.
