## Подробное объяснение текста автора курса:

### **Контекст и цель видео**

**Текущее состояние:**

- Регистрация пользователя с хешированием пароля уже реализована
- Пользователи создаются с безопасно хешированными паролями

**Цель видео:**

- Создать endpoint для входа пользователей (sign in)
- Реализовать аутентификацию по email и паролю

---

### **Шаг 1: Создание DTO для входа (SignInDto)**

**Расположение файла:**

```
src/auth/dtos/sign-in.dto.ts
```

**Структура DTO:**

```typescript
export class SignInDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsNotEmpty()
  @IsString()
  password: string;
}
```

**Объяснение валидации:**

- `@IsEmail()` - проверяет, что поле содержит валидный email
- `@IsNotEmpty()` - поле не может быть пустым
- `@IsString()` - пароль должен быть строкой

---

### **Шаг 2: Создание endpoint в AuthController**

**Метод контроллера:**

```typescript
@Post('sign-in')
public async signIn(@Body() signInDto: SignInDto) {
  return this.authService.signIn(signInDto);
}
```

**Детали:**

- HTTP метод: POST
- URL путь: `/auth/sign-in`
- Принимает тело запроса типа `SignInDto`
- Делегирует выполнение `AuthService.signIn()`

---

### **Шаг 3: Подготовка AuthService**

**Изменения в AuthService:**

- Переименование метода `login` в `signIn`
- Удаление старой реализации
- Принятие `SignInDto` в качестве параметра

---

### **Шаг 4: Процесс аутентификации**

**Логика входа пользователя:**

1. **Поиск пользователя по email**

   - Email уникален, поэтому используется для поиска
   - Если пользователь не найден - исключение

2. **Сравнение паролей**

   - Сравнение введенного пароля с хешем из базы данных
   - Использование `HashingProvider.comparePassword()`

3. **Подтверждение успешного входа**
   - Пока простое подтверждение
   - В будущем - выдача JWT токена

---

### **Шаг 5: Архитектурное решение для поиска пользователя**

**Проблема:**
Нужен способ найти пользователя по email в `AuthService`

**Возможные решения:**

1. **Прямой инжект репозитория в AuthService** ❌

   - Нарушает границы модулей
   - Создает сильную связность

2. **Создание специализированного провайдера** ✅
   - Сохраняет инкапсуляцию
   - Соблюдает принцип единой ответственности

---

### **Шаг 6: Создание FindOneUserByEmailProvider**

**Команда создания:**

```bash
nest generate provider users/providers/find-one-user-by-email --no-spec
```

**Реализация провайдера:**

```typescript
@Injectable()
export class FindOneUserByEmailProvider {
  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>
  ) {}

  public async findOneByEmail(email: string): Promise<User> {
    let user: User | undefined = undefined;

    try {
      // Поиск пользователя по email
      user = await this.usersRepository.findOneBy({ email });
    } catch (error) {
      // Обработка ошибок базы данных
      throw new RequestTimeoutException("Could not fetch the user", {
        description: "Database connection error",
      });
    }

    // Проверка существования пользователя
    if (!user) {
      throw new UnauthorizedException("User does not exist");
    }

    return user;
  }
}
```

**Ключевые моменты реализации:**

1. **Поиск в базе данных:**

   - `usersRepository.findOneBy({ email })`
   - Возвращает `null` если пользователь не найден

2. **Обработка ошибок:**

   - `RequestTimeoutException` - проблемы с подключением к БД
   - `UnauthorizedException` - пользователь не существует

3. **Возврат результата:**
   - Возвращает сущность `User` если пользователь найден

---

### **Шаг 7: Интеграция провайдера в UsersService**

**Два подхода к экспорту:**

1. **Прямой экспорт провайдера** ❌

   - Экспорт `FindOneUserByEmailProvider` из `UsersModule`
   - Прямой инжект в `AuthService`
   - Сложно отслеживать зависимости

2. **Прокси-метод в UsersService** ✅
   - Провайдер остается приватным в модуле
   - `UsersService` предоставляет публичный метод
   - Единая точка доступа к функциональности

**Реализация прокси-метода:**

```typescript
@Injectable()
export class UsersService {
  constructor(
    // Инжект провайдера
    private readonly findOneUserByEmailProvider: FindOneUserByEmailProvider
  ) {}

  // Прокси-метод
  public async findOneByEmail(email: string): Promise<User> {
    return this.findOneUserByEmailProvider.findOneByEmail(email);
  }
}
```

---

### **Шаг 8: Dependency Injection цепочка**

**Полный путь зависимостей:**

```
AuthController
  → AuthService
  → UsersService (через существующую циклическую зависимость)
  → FindOneUserByEmailProvider
  → UserRepository (TypeORM)
  → Database
```

**Преимущества архитектуры:**

1. **Инкапсуляция:**

   - Логика поиска пользователя изолирована в провайдере
   - `UsersService` выступает как фасад

2. **Переиспользуемость:**

   - `findOneByEmail` может использоваться в других сервисах
   - Единая логика обработки ошибок

3. **Тестируемость:**
   - Легко мокировать `UsersService.findOneByEmail()`
   - Изолированное тестирование провайдера

---

### **Шаг 9: Текущий прогресс и следующий шаг**

**Что уже сделано:**

- ✅ Создан `SignInDto` для валидации входящих данных
- ✅ Добавлен endpoint `/auth/sign-in` в контроллер
- ✅ Подготовлен `AuthService.signIn()` метод
- ✅ Создан `FindOneUserByEmailProvider` для поиска пользователей
- ✅ Добавлен прокси-метод в `UsersService`

**Что осталось сделать (для следующего видео):**

- ❌ Завершить реализацию `AuthService.signIn()`
- ❌ Добавить сравнение паролей с помощью `HashingProvider`
- ❌ Реализовать возврат JWT токена при успешной аутентификации

---

### **Архитектурные принципы, примененные автором**

1. **Single Responsibility Principle:**

   - `FindOneUserByEmailProvider` отвечает только за поиск по email
   - `UsersService` управляет доступом к провайдерам

2. **Dependency Inversion:**

   - `AuthService` зависит от абстракции (`UsersService`)
   - Конкретная реализация скрыта в модуле пользователей

3. **Separation of Concerns:**

   - Валидация данных в DTO
   - Маршрутизация в контроллере
   - Бизнес-логика в сервисах
   - Доступ к данным в провайдерах

4. **Error Handling Strategy:**
   - Специфичные исключения для разных сценариев
   - Единообразная обработка ошибок базы данных

---

### **Поток данных при входе пользователя (после завершения)**

```
HTTP POST /auth/sign-in
  → AuthController.signIn()
  → SignInDto (валидация)
  → AuthService.signIn()
  → UsersService.findOneByEmail()
  → FindOneUserByEmailProvider.findOneByEmail()
  → UserRepository.findOneBy()
  → Database query
  → HashingProvider.comparePassword()
  → JWT Token generation
  → HTTP Response
```
