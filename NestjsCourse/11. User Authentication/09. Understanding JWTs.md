## Углубленное объяснение JWT токенов с техническими деталями

### **Архитектура JWT: Детальный разбор**

#### **Base64Url Encoding - не шифрование!**

**Важное различие:**

- **Шифрование (Encryption)**: данные преобразуются так, что только с ключом можно их прочитать
- **Кодирование (Encoding)**: данные преобразуются в другой формат для передачи, но легко декодируются обратно

**Пример кодирования header:**

```typescript
// Исходный JSON header
const header = {
  alg: "HS256",
  typ: "JWT",
};

// Преобразуем в строку
const headerString = JSON.stringify(header);
// "{"alg":"HS256","typ":"JWT"}"

// Base64Url кодирование
const encodedHeader = base64url(headerString);
// "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
```

**Base64Url vs Base64:**

- Заменяет `+` на `-` и `/` на `_`
- Убирает padding `=`
- Безопасно для URL

---

### **Детальное объяснение трех компонентов JWT**

#### **1. Header (Заголовок) - техническая информация**

**Полный список возможных полей:**

```json
{
  "alg": "HS256", // Алгоритм подписи (обязательный)
  "typ": "JWT", // Тип токена (обязательный)
  "cty": "JWT", // Content Type (опционально)
  "kid": "key-id-123" // Key ID (опционально)
}
```

**Алгоритмы подписи:**

| Тип   | Алгоритмы           | Использование                                      |
| ----- | ------------------- | -------------------------------------------------- |
| HMAC  | HS256, HS384, HS512 | Симметричное шифрование, один ключ                 |
| RSA   | RS256, RS384, RS512 | Асимметричное шифрование, приватный/публичный ключ |
| ECDSA | ES256, ES384, ES512 | Эллиптическая криптография                         |

**Почему HS256 популярен:**

- Производительность: быстрые операции
- Простота: один секретный ключ
- Достаточная безопасность для большинства случаев

#### **2. Payload (Полезная нагрузка) - данные**

**Стандартные claims (заявки):**

```json
{
  // Идентификатор субъекта (пользователя)
  "sub": "1234567890",

  // Issuer (эмитент) - кто выпустил токен
  "iss": "https://yourdomain.com",

  // Audience (аудитория) - для кого предназначен
  "aud": "https://yourapi.com",

  // Expiration Time (время истечения) - Unix timestamp
  "exp": 1516239022,

  // Not Before (не ранее) - токен недействителен до
  "nbf": 1516239022,

  // Issued At (выпущен) - когда создан
  "iat": 1516239022,

  // JWT ID - уникальный идентификатор
  "jti": "a1b2c3d4e5"
}
```

**Кастомные claims:**

```json
{
  "sub": "12345",
  "email": "user@example.com",
  "roles": ["user", "admin"],
  "permissions": ["read:data", "write:data"],
  "tenant_id": "company-123"
}
```

**ВАЖНОЕ ПРЕДУПРЕЖДЕНИЕ О БЕЗОПАСНОСТИ:**

```typescript
// ❌ ОПАСНО - чувствительные данные
{
  "sub": "12345",
  "password": "my_secret_password", // ЛИБО НИКОГДА ТАК НЕ ДЕЛАЙТЕ!
  "credit_card": "1234-5678-9012-3456"
}

// ✅ БЕЗОПАСНО - только идентификаторы
{
  "sub": "12345",
  "email": "user@example.com", // Если email не чувствительный
  "user_role": "premium"
}
```

#### **3. Signature (Подпись) - механизм безопасности**

**Процесс создания подписи детально:**

```typescript
// Псевдокод создания подписи
function createSignature(header, payload, secret) {
  // 1. Кодируем header и payload
  const encodedHeader = base64urlEncode(JSON.stringify(header));
  const encodedPayload = base64urlEncode(JSON.stringify(payload));

  // 2. Создаем данные для подписи
  const signingInput = `${encodedHeader}.${encodedPayload}`;

  // 3. Создаем подпись с использованием алгоритма и секрета
  const signature = HMACSHA256(signingInput, secret);

  // 4. Кодируем подпись
  const encodedSignature = base64urlEncode(signature);

  return encodedSignature;
}
```

**Пример реального вычисления:**

```
Header: {"alg":"HS256","typ":"JWT"}
→ Base64Url: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"

Payload: {"sub":"12345","email":"user@example.com"}
→ Base64Url: "eyJzdWIiOiIxMjM0NSIsImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSJ9"

Signing Input: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSJ9"

Signature: HMACSHA256(signingInput, "my-secret-key")
→ Base64Url: "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

Final JWT: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
```

---

### **Процесс верификации JWT - технические детали**

#### **Как сервер проверяет JWT:**

```typescript
function verifyJWT(token, secret) {
  // 1. Разделяем токен на части
  const [encodedHeader, encodedPayload, encodedSignature] = token.split(".");

  // 2. Декодируем header и payload
  const header = JSON.parse(base64urlDecode(encodedHeader));
  const payload = JSON.parse(base64urlDecode(encodedPayload));

  // 3. Проверяем алгоритм
  if (header.alg !== "HS256") {
    throw new Error("Unsupported algorithm");
  }

  // 4. Проверяем expiration time
  if (payload.exp && Date.now() >= payload.exp * 1000) {
    throw new Error("Token expired");
  }

  // 5. Воссоздаем подпись с тем же секретом
  const signingInput = `${encodedHeader}.${encodedPayload}`;
  const expectedSignature = HMACSHA256(signingInput, secret);
  const expectedEncodedSignature = base64urlEncode(expectedSignature);

  // 6. Сравниваем подписи
  if (encodedSignature !== expectedEncodedSignature) {
    throw new Error("Invalid signature");
  }

  // 7. Если все проверки пройдены - токен валиден
  return payload;
}
```

---

### **Практические аспекты безопасности**

#### **Защита секретного ключа:**

```typescript
// ❌ ОПАСНО - ключ в коде
const secret = "my-weak-secret";

// ✅ БЕЗОПАСНО - ключ из environment variables
const secret = process.env.JWT_SECRET;

// ✅ ЕЩЕ ЛУЧШЕ - длинный случайный ключ
// Генерация: openssl rand -base64 64
const secret = process.env.JWT_SECRET; // Минимум 32 байта
```

#### **Время жизни токенов:**

```typescript
// Короткоживущие access tokens
const accessToken = jwt.sign(payload, secret, {
  expiresIn: "15m", // 15 минут
});

// Долгоживущие refresh tokens
const refreshToken = jwt.sign({ sub: userId }, secret, {
  expiresIn: "7d", // 7 дней
});
```

---

### **Реальные атаки и защита**

#### **1. Атака подмены алгоритма:**

```json
// Злоумышленник меняет алгоритм на "none"
{
  "alg": "none",
  "typ": "JWT"
}
```

**Защита:** Всегда явно проверяйте алгоритм на сервере

#### **2. Атака перебором ключа:**

- Слабые ключи уязвимы для brute-force
- Короткое время жизни токена ограничивает ущерб

**Защита:** Используйте ключи длиной минимум 256 бит (32 байта)

---

### **Поток данных в enterprise-системе**

#### **Полный цикл аутентификации:**

```
┌─────────┐          ┌──────────┐          ┌─────────────┐
│ Клиент  │          │  Сервер  │          │ База данных │
└────┬────┘          └────┬─────┘          └──────┬──────┘
     │                    │                       │
     │ 1. email/password  │                       │
     │ ──────────────────>│                       │
     │                    │                       │
     │                    │ 2. Поиск пользователя │
     │                    │ ─────────────────────>│
     │                    │                       │
     │                    │ 3. Проверка хеша      │
     │                    │ <─────────────────────│
     │                    │                       │
     │                    │ 4. Генерация JWT      │
     │                    │ (header+payload+      │
     │                    │ signature)            │
     │                    │                       │
     │ 5. Возврат JWT     │                       │
     │ <──────────────────│                       │
     │                    │                       │
     │ 6. Запрос с JWT    │                       │
     │ в Authorization    │                       │
     │ header             │                       │
     │ ──────────────────>│                       │
     │                    │                       │
     │                    │ 7. Верификация подписи│
     │                    │ (без запроса к БД)    │
     │                    │                       │
     │ 8. Данные пользователя                     │
     │ <──────────────────│                       │
```

---

### **Реализация в NestJS - превью**

**Структура модулей:**

```
src/
├── auth/
│   ├── jwt/
│   │   ├── jwt.module.ts
│   │   ├── jwt.service.ts
│   │   └── interfaces/
│   └── guards/
│       └── jwt-auth.guard.ts
```

**Пример JWT service:**

```typescript
@Injectable()
export class JwtService {
  constructor(private readonly configService: ConfigService) {}

  async generateAccessToken(user: User): Promise<string> {
    const payload = {
      sub: user.id,
      email: user.email,
      roles: user.roles,
    };

    return jwt.sign(payload, this.configService.get("JWT_SECRET"), {
      expiresIn: "15m",
      issuer: "your-app-name",
      audience: "your-app-domain",
    });
  }

  async verifyToken(token: string): Promise<any> {
    return jwt.verify(token, this.configService.get("JWT_SECRET"), {
      issuer: "your-app-name",
      audience: "your-app-domain",
    });
  }
}
```

---

### **Производительность и масштабируемость**

**Преимущества stateless подхода:**

- **Нет сессий в памяти** - не нужно синхронизировать между серверами
- **Быстрая проверка** - только криптографическая операция
- **Кеширование** - можно кешировать публичные ключи для RS256

**Производительность проверки:**

```
HMAC-SHA256 verification: ~0.1ms
RSA-SHA256 verification: ~1ms
Database session lookup: ~5-10ms
```

---

### **Best Practices для production**

1. **Используйте разные секреты для разных сред**
2. **Регулярно ротируйте ключи**
3. **Используйте короткое время жизни access token'ов**
4. **Реализуйте механизм refresh token'ов**
5. **Всегда проверяйте issuer и audience**
6. **Используйте HTTPS для передачи токенов**
7. **Рассмотрите использование httpOnly cookies для хранения**
