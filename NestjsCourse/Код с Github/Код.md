`src/app.module.ts`

```typescript
import { ConfigModule, ConfigService } from "@nestjs/config";

import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { AuthModule } from "./auth/auth.module";
import { MetaOptionsModule } from "./meta-options/meta-options.module";
import { Module } from "@nestjs/common";
import { PaginationModule } from "./common/pagination/pagination.module";
import { PostsModule } from "./posts/posts.module";
import { Tag } from "./tags/tag.entity";
import { TagsModule } from "./tags/tags.module";
import { TypeOrmModule } from "@nestjs/typeorm";
/**
 * Importing Entities
 * */
import { User } from "./users/user.entity";
import { UsersModule } from "./users/users.module";
import appConfig from "./config/app.config";
import databaseConfig from "./config/database.config";
import enviromentValidation from "./config/enviroment.validation";

// Get the current NODE_ENV
const ENV = process.env.NODE_ENV;

@Module({
  imports: [
    UsersModule,
    PostsModule,
    AuthModule,
    ConfigModule.forRoot({
      isGlobal: true,
      //envFilePath: ['.env.development', '.env'],
      envFilePath: !ENV ? ".env" : `.env.${ENV}`,
      load: [appConfig, databaseConfig],
      validationSchema: enviromentValidation,
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: "postgres",
        //entities: [User],
        synchronize: configService.get("database.synchronize"),
        port: configService.get("database.port"),
        username: configService.get("database.user"),
        password: configService.get("database.password"),
        host: configService.get("database.host"),
        autoLoadEntities: configService.get("database.autoLoadEntities"),
        database: configService.get("database.name"),
      }),
    }),
    TagsModule,
    MetaOptionsModule,
    PaginationModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

`src/main.ts`

```typescript
import { DocumentBuilder, SwaggerModule } from "@nestjs/swagger";

import { AppModule } from "./app.module";
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  /*
   * Use validation pipes globally
   */
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    })
  );

  /**
   * swagger configuration
   */
  const config = new DocumentBuilder()
    .setTitle("NestJs Masterclass - Blog app API")
    .setDescription("Use the base API URL as http://localhost:3000")
    .setTermsOfService("http://localhost:3000/terms-of-service")
    .setLicense(
      "MIT License",
      "https://github.com/git/git-scm.com/blob/main/MIT-LICENSE.txt"
    )
    .addServer("http://localhost:3000")
    .setVersion("1.0")
    .build();

  // Instantiate Document
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup("api", app, document);

  await app.listen(3000);
}
bootstrap();
```

`src/app.service.ts`

```typescript
import { Injectable } from "@nestjs/common";

@Injectable()
export class AppService {
  getHello(): string {
    return "Hello From NestJS!";
  }
}
```

`src/app.controller.ts`

```typescript
import { Controller, Get } from "@nestjs/common";

import { AppService } from "./app.service";

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
}
```

`src/app.endpoints.http`

```
## Get Request For App controller
GET http://localhost:3000/
```

`src/auth/auth.module.ts`

```typescript
import { Module, forwardRef } from "@nestjs/common";

import { AuthController } from "./auth.controller";
import { AuthService } from "./providers/auth.service";
import { UsersModule } from "src/users/users.module";

@Module({
  controllers: [AuthController],
  providers: [AuthService],
  imports: [forwardRef(() => UsersModule)],
  exports: [AuthService],
})
export class AuthModule {}
```

`src/auth/auth.controller.ts`

```typescript
import { AuthService } from "./providers/auth.service";
import { Controller } from "@nestjs/common";

@Controller("auth")
export class AuthController {
  constructor(
    /*
     * Injecting Auth Service
     */
    private readonly authService: AuthService
  ) {}
}
```

`src/auth/providers/auth.service.ts`

```typescript
import { Inject, Injectable, forwardRef } from "@nestjs/common";

import { UsersService } from "src/users/providers/users.service";

@Injectable()
export class AuthService {
  constructor(
    // Injecting UserService
    @Inject(forwardRef(() => UsersService))
    private readonly usersService: UsersService
  ) {}

  public login(email: string, password: string, id: string) {
    const user = this.usersService.findOneById(1);
    // login
    return "SAMPLE_TOKEN";
  }

  public isAuth() {
    return true;
  }
}
```

`src/meta-options/meta-options.module.ts`

```typescript
import { MetaOption } from "./meta-option.entity";
import { MetaOptionsController } from "./meta-options.controller";
import { MetaOptionsService } from "./providers/meta-options.service";
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

@Module({
  controllers: [MetaOptionsController],
  imports: [TypeOrmModule.forFeature([MetaOption])],
  providers: [MetaOptionsService],
  exports: [MetaOptionsService],
})
export class MetaOptionsModule {}
```

`src/meta-options/providers/meta-options.service.ts`

```typescript
import { CreatePostMetaOptionsDto } from "../dtos/create-post-meta-options.dto";
import { Injectable } from "@nestjs/common";
import { MetaOption } from "../meta-option.entity";
import { Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";

@Injectable()
export class MetaOptionsService {
  constructor(
    /**
     * Injecting metaOptions repository
     */
    @InjectRepository(MetaOption)
    private metaOptionsRepository: Repository<MetaOption>
  ) {}

  public async create(createPostMetaOptionsDto: CreatePostMetaOptionsDto) {
    let metaOption = this.metaOptionsRepository.create(
      createPostMetaOptionsDto
    );
    return await this.metaOptionsRepository.save(metaOption);
  }
}
```

`src/meta-options/meta-options.controller.ts`

```typescript
import { CreatePostMetaOptionsDto } from "./dtos/create-post-meta-options.dto";
import { MetaOptionsService } from "./providers/meta-options.service";
import { Body, Controller, Post } from "@nestjs/common";

@Controller("meta-options")
export class MetaOptionsController {
  constructor(
    /**
     * Inject MetaOptionsService
     * */
    private readonly MetaOptionsService: MetaOptionsService
  ) {}

  @Post()
  public async create(
    @Body() createPostMetaOptionsDto: CreatePostMetaOptionsDto
  ) {
    return this.MetaOptionsService.create(createPostMetaOptionsDto);
  }
}
```

`src/meta-options/meta-option.entity.ts`

```typescript
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  OneToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from "typeorm";

import { Post } from "src/posts/post.entity";

@Entity()
export class MetaOption {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: "json",
    nullable: false,
  })
  metaValue: string;

  @CreateDateColumn()
  createDate: Date;

  @UpdateDateColumn()
  updateDate: Date;

  @OneToOne(() => Post, (post) => post.metaOptions, {
    onDelete: "CASCADE",
  })
  @JoinColumn()
  post: Post;
}
```

`src/meta-options/http/meta-options.post.endpoints.http`

```typescript
POST http://localhost:3000/meta-options
Content-Type: application/json

{
  "metaValue": "{ \"sidebarEnabled\": true, \"footerActive\": true }"
}
```

`src/meta-options/dtos/create-post-meta-options.dto.ts`

```typescript
import { IsJSON, IsNotEmpty, IsString, MaxLength } from "class-validator";

export class CreatePostMetaOptionsDto {
  @IsNotEmpty()
  @IsJSON()
  metaValue: string;
}
```

`src/config/app.config.ts`

```typescript
import { registerAs } from "@nestjs/config";

export default registerAs("appConfig", () => ({
  environment: process.env.NODE_ENV || "production",
}));
```

`src/config/database.config.ts`

```typescript
import { registerAs } from "@nestjs/config";

export default registerAs("database", () => ({
  host: process.env.DATABASE_HOST || "localhost",
  port: parseInt(process.env.DATABASE_PORT) || 5432,
  user: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  name: process.env.DATABASE_NAME,
  synchronize: process.env.DATABASE_SYNC === "true" ? true : false,
  autoLoadEntities: process.env.DATABASE_AUTOLOAD === "true" ? true : false,
}));
```

`src/config/enviroment.validation.ts`

```typescript
import * as Joi from "joi";

export default Joi.object({
  NODE_ENV: Joi.string()
    .valid("development", "production", "test", "provision")
    .default("development"),
  DATABASE_PORT: Joi.number().port().default(5432),
  DATABASE_PASSWORD: Joi.string().required(),
  DATABASE_HOST: Joi.string().required(),
  DATABASE_NAME: Joi.string().required(),
  DATABASE_USER: Joi.string().required(),
  PROFILE_API_KEY: Joi.string().required(),
});
```

`src/common/pagination/pagination.module.ts`

```typescript
import { Module } from "@nestjs/common";
import { PaginationProvider } from "./providers/pagination.provider";

@Module({
  providers: [PaginationProvider],
  exports: [PaginationProvider],
})
export class PaginationModule {}
```

`src/common/pagination/dtos/pagination-query.dto.ts`

```typescript
import { IsOptional, IsPositive } from "class-validator";

import { Type } from "class-transformer";

export class PaginationQueryDto {
  @IsOptional()
  @IsPositive()
  // Number of entries to return
  limit?: number = 10;

  @IsOptional()
  @IsPositive()
  // Number of entries to skip from start
  page?: number = 1;
}
```

`src/common/pagination/interfaces/paginated.interface.ts`

```typescript
export interface Paginated<T> {
  data: T[];
  meta: {
    itemsPerPage: number;
    totalItems: number;
    currentPage: number;
    totalPages: number;
  };
  links: {
    first?: string;
    previous?: string;
    current: string;
    next?: string;
    last?: string;
  };
}
```

`src/common/pagination/providers/pagination.provider.ts`

```typescript
import { Inject, Injectable } from "@nestjs/common";
import { ObjectLiteral } from "typeorm";
import { Paginated } from "../interfaces/paginated.interface";
import { PaginationQueryDto } from "../dtos/pagination-query.dto";
import { Repository } from "typeorm";
import { REQUEST } from "@nestjs/core";
import { Request } from "express";
import * as url from "url";

@Injectable()
export class PaginationProvider {
  /**
   * Use Constructor to Inject Request
   * */
  constructor(@Inject(REQUEST) private readonly request: Request) {}

  public async paginateQuery<T extends ObjectLiteral>(
    paginationQuery: PaginationQueryDto,
    repository: Repository<T>
  ): Promise<Paginated<T>> {
    let results = await repository.find({
      skip: (paginationQuery.page - 1) * paginationQuery.limit,
      take: paginationQuery.limit,
    });

    /**
     * Create the request URLs
     */
    const baseURL =
      this.request.protocol + "://" + this.request.headers.host + "/";
    const newUrl = new URL(this.request.url, baseURL);

    // Calculate page numbers
    const totalItems = await repository.count();
    const totalPages = Math.ceil(totalItems / paginationQuery.limit);
    const nextPage =
      paginationQuery.page === totalPages
        ? paginationQuery.page
        : paginationQuery.page + 1;
    const previousPage =
      paginationQuery.page === 1
        ? paginationQuery.page
        : paginationQuery.page - 1;

    let finalResponse = {
      data: results,
      meta: {
        itemsPerPage: paginationQuery.limit,
        totalItems: totalItems,
        currentPage: paginationQuery.page,
        totalPages: Math.ceil(totalItems / paginationQuery.limit),
      },
      links: {
        first: `${newUrl.origin}${newUrl.pathname}?limit=${paginationQuery.limit}&page=1`,
        last: `${newUrl.origin}${newUrl.pathname}?limit=${paginationQuery.limit}&page=${totalPages}`,
        current: `${newUrl.origin}${newUrl.pathname}?limit=${paginationQuery.limit}&page=${paginationQuery.page}`,
        next: `${newUrl.origin}${newUrl.pathname}?limit=${paginationQuery.limit}&page=${nextPage}`,
        previous: `${newUrl.origin}${newUrl.pathname}?limit=${paginationQuery.limit}&page=${previousPage}`,
      },
    };

    return finalResponse;
  }
}
```

`src/posts/posts.module.ts`

```typescript
import { MetaOption } from "src/meta-options/meta-option.entity";
import { Module } from "@nestjs/common";
import { PaginationModule } from "src/common/pagination/pagination.module";
import { Post } from "./post.entity";
import { PostsController } from "./posts.controller";
import { PostsService } from "./providers/posts.service";
import { TagsModule } from "src/tags/tags.module";
import { TypeOrmModule } from "@nestjs/typeorm";
import { UsersModule } from "src/users/users.module";

@Module({
  controllers: [PostsController],
  providers: [PostsService],
  imports: [
    UsersModule,
    TagsModule,
    PaginationModule,
    TypeOrmModule.forFeature([Post, MetaOption]),
  ],
})
export class PostsModule {}
```

`src/posts/posts.controller.ts`

```typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
} from "@nestjs/common";
import { PostsService } from "./providers/posts.service";
import { ApiOperation, ApiResponse, ApiTags } from "@nestjs/swagger";
import { CreatePostDto } from "./dtos/create-post.dto";
import { PatchPostDto } from "./dtos/patch-post.dto";
import { GetPostsDto } from "./dtos/get-post.dto";

@Controller("posts")
@ApiTags("Posts")
export class PostsController {
  constructor(
    /*
     *  Injecting Posts Service
     */
    private readonly postsService: PostsService
  ) {}

  /*
   * GET localhost:3000/posts/:userId
   */
  @Get("/:userId?")
  public getPosts(
    @Param("userId") userId: string,
    @Query() postQuery: GetPostsDto
  ) {
    return this.postsService.findAll(postQuery, userId);
  }

  @ApiOperation({
    summary: "Creates a new blog post",
  })
  @ApiResponse({
    status: 201,
    description: "You get a 201 response if your post is created successfully",
  })
  @Post()
  public createPost(@Body() createPostDto: CreatePostDto) {
    return this.postsService.create(createPostDto);
  }

  @ApiOperation({
    summary: "Updates an existing blog post",
  })
  @ApiResponse({
    status: 200,
    description: "A 200 response if the post is updated successfully",
  })
  @Patch()
  public updatePost(@Body() patchPostDto: PatchPostDto) {
    return this.postsService.update(patchPostDto);
  }

  @Delete()
  public deletePost(@Query("id", ParseIntPipe) id: number) {
    return this.postsService.delete(id);
  }
}
```

`src/posts/post.entity.ts`

```typescript
import {
  Column,
  Entity,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToOne,
  PrimaryGeneratedColumn,
} from "typeorm";

import { CreatePostMetaOptionsDto } from "../meta-options/dtos/create-post-meta-options.dto";
import { MetaOption } from "src/meta-options/meta-option.entity";
import { Tag } from "src/tags/tag.entity";
import { User } from "src/users/user.entity";
import { postStatus } from "./enums/postStatus.enum";
import { postType } from "./enums/postType.enum";

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: "varchar",
    length: 512,
    nullable: false,
  })
  title: string;

  @Column({
    type: "enum",
    enum: postType,
    nullable: false,
    default: postType.POST,
  })
  postType: postType;

  @Column({
    type: "varchar",
    length: 256,
    nullable: false,
    unique: true,
  })
  slug: string;

  @Column({
    type: "enum",
    enum: postStatus,
    nullable: false,
    default: postStatus.DRAFT,
  })
  status: postStatus;

  @Column({
    type: "text",
    nullable: true,
  })
  content?: string;

  @Column({
    type: "text",
    nullable: true,
  })
  schema?: string;

  @Column({
    type: "varchar",
    length: 1024,
    nullable: true,
  })
  featuredImageUrl?: string;

  @Column({
    type: "timestamp", // 'datetime' in mysql
    nullable: true,
  })
  publishOn?: Date;

  @OneToOne(() => MetaOption, (metaOptions) => metaOptions.post, {
    cascade: true,
    eager: true,
  })
  metaOptions?: MetaOption;

  @ManyToOne(() => User, (user) => user.posts, {
    eager: true,
  })
  author: User;

  @ManyToMany(() => Tag, (tag) => tag.posts, {
    eager: true,
  })
  @JoinTable()
  tags?: Tag[];
}
```

`src/posts/dtos/create-post.dto.ts`

```typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsArray,
  IsEnum,
  IsISO8601,
  IsInt,
  IsJSON,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUrl,
  Matches,
  Max,
  MaxLength,
  Min,
  MinLength,
  ValidateNested,
  isNotEmpty,
} from "class-validator";

import { CreatePostMetaOptionsDto } from "../../meta-options/dtos/create-post-meta-options.dto";
import { CreateTagDto } from "src/tags/dtos/create-tag.dto";
import { DeepPartial } from "typeorm";
import { Type } from "class-transformer";
import { postStatus } from "../enums/postStatus.enum";
import { postType } from "../enums/postType.enum";

export class CreatePostDto {
  @ApiProperty({
    example: "This is a title",
    description: "This is the title for the blog post",
  })
  @IsString()
  @MinLength(4)
  @MaxLength(512)
  @IsNotEmpty()
  title: string;

  @ApiProperty({
    enum: postType,
    description: "Possible values, 'post', 'page', 'story', 'series'",
  })
  @IsEnum(postType)
  @IsNotEmpty()
  postType: postType;

  @ApiProperty({
    description: "For Example - 'my-url'",
    example: "my-blog-post",
  })
  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {
    message:
      'A slug should be all small letters and uses only "-" and without spaces. For example "my-url"',
  })
  @MaxLength(256)
  slug: string;

  @ApiProperty({
    enum: postStatus,
    description: "Possible values 'draft', 'scheduled', 'review', 'published'",
  })
  @IsEnum(postStatus)
  @IsNotEmpty()
  status: postStatus;

  @ApiPropertyOptional({
    description: "This is the content of the post",
    example: "The post content",
  })
  @IsString()
  @IsOptional()
  content?: string;

  @ApiPropertyOptional({
    description:
      "Serialize your JSON object else a validation error will be thrown",
    example:
      '{\r\n "@context": "https://schema.org",\r\n "@type": "Person"\r\n }',
  })
  @IsOptional()
  @IsJSON()
  schema?: string;

  @ApiPropertyOptional({
    description: "Featured image for your blog post",
    example: "http://localhost.com/images/image1.jpg",
  })
  @IsOptional()
  @IsUrl()
  @MaxLength(1024)
  featuredImageUrl?: string;

  @ApiPropertyOptional({
    description: "The date on which the blog post is published",
    example: "2024-03-16T07:46:32+0000",
  })
  @IsISO8601()
  @IsOptional()
  publishOn?: Date;

  @ApiPropertyOptional({
    description: "Array of ids of tags",
    example: [1, 2],
  })
  @IsOptional()
  @IsArray()
  @IsInt({ each: true })
  tags?: number[];

  @ApiPropertyOptional({
    type: "object",
    required: false,
    items: {
      type: "object",
      properties: {
        metavalue: {
          type: "json",
          description: "The metaValue is a JSON string",
          example: '{"sidebarEnabled": true}',
        },
      },
    },
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => CreatePostMetaOptionsDto)
  metaOptions?: CreatePostMetaOptionsDto | null;

  @ApiProperty({
    type: "integer",
    required: true,
    example: 1,
  })
  @IsNotEmpty()
  @IsInt()
  authorId: number;
}
```

`src/posts/dtos/patch-post.dto.ts`

```typescript
import { ApiProperty, PartialType } from "@nestjs/swagger";
import { IsInt, IsNotEmpty } from "class-validator";

import { CreatePostDto } from "./create-post.dto";

export class PatchPostDto extends PartialType(CreatePostDto) {
  @ApiProperty({
    description: "The ID of the post that needs to be updated",
  })
  @IsInt()
  @IsNotEmpty()
  id: number;
}
```

`src/posts/dtos/get-post.dto.ts`

```typescript
import { IsDate, IsOptional } from "class-validator";

import { IntersectionType } from "@nestjs/swagger";
import { PaginationQueryDto } from "src/common/pagination/dtos/pagination-query.dto";
import { Type } from "class-transformer";

class GetPostsBaseDto {
  @IsDate()
  @IsOptional()
  startDate?: Date;

  @IsDate()
  @IsOptional()
  endDate?: Date;
}

export class GetPostsDto extends IntersectionType(
  GetPostsBaseDto,
  PaginationQueryDto
) {}
```

`src/posts/enums/postStatus.enum.ts`

```typescript
//draft, scheduled, review, published
export enum postStatus {
  DRAFT = "draft",
  SCHEDULED = "scheduled",
  REVIEW = "review",
  PUBLISHED = "published",
}
```

`src/posts/enums/postType.enum.ts`

```typescript
export enum postType {
  POST = "post",
  PAGE = "page",
  STORY = "story",
  SERIES = "series",
}
```

`src/posts/providers/posts.service.ts`

```typescript
import {
  BadRequestException,
  Body,
  Injectable,
  RequestTimeoutException,
} from "@nestjs/common";
import { UsersService } from "src/users/providers/users.service";
import { CreatePostDto } from "../dtos/create-post.dto";
import { Repository } from "typeorm";
import { Post } from "../post.entity";
import { InjectRepository } from "@nestjs/typeorm";
import { MetaOption } from "src/meta-options/meta-option.entity";
import { TagsService } from "src/tags/providers/tags.service";
import { PatchPostDto } from "../dtos/patch-post.dto";
import { GetPostsDto } from "../dtos/get-post.dto";
import { PaginationProvider } from "src/common/pagination/providers/pagination.provider";
import { Paginated } from "src/common/pagination/interfaces/paginated.interface";

@Injectable()
export class PostsService {
  constructor(
    /*
     * Injecting Users Service
     */
    private readonly usersService: UsersService,
    /**
     * Inject postsRepository
     */
    @InjectRepository(Post)
    private readonly postsRepository: Repository<Post>,
    /**
     * inject metaOptionsRepository
     */
    @InjectRepository(MetaOption)
    private readonly metaOptionsRepository: Repository<MetaOption>,
    /**
     * Inject TagsService
     */
    private readonly tagsService: TagsService,
    /**
     * Inject the paginationProvider
     */
    private readonly paginationProvider: PaginationProvider
  ) {}

  /**
   * Creating new posts
   */
  public async create(@Body() createPostDto: CreatePostDto) {
    // Find author from database based on authorId
    let author = await this.usersService.findOneById(createPostDto.authorId);
    // Find tags
    let tags = await this.tagsService.findMultipleTags(createPostDto.tags);

    // Create post
    let post = this.postsRepository.create({
      ...createPostDto,
      author: author,
      tags: tags,
    });

    // return the post
    return await this.postsRepository.save(post);
  }

  public async findAll(
    postQuery: GetPostsDto,
    userId: string
  ): Promise<Paginated<Post>> {
    let posts = await this.paginationProvider.paginateQuery(
      {
        limit: postQuery.limit,
        page: postQuery.page,
      },
      this.postsRepository
    );

    return posts;
  }

  public async update(patchPostDto: PatchPostDto) {
    let tags = undefined;
    let post = undefined;

    // Find the Tags
    try {
      tags = await this.tagsService.findMultipleTags(patchPostDto.tags);
    } catch (error) {
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the database",
        }
      );
    }

    /**
     * If tags were not found
     * Need to be equal number of tags
     */
    if (!tags || tags.length !== patchPostDto.tags.length) {
      throw new BadRequestException(
        "Please check your tag Ids and ensure they are correct"
      );
    }

    // Find the Post
    try {
      // Returns null if the post does not exist
      post = await this.postsRepository.findOneBy({
        id: patchPostDto.id,
      });
    } catch (error) {
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the database",
        }
      );
    }

    if (!post) {
      throw new BadRequestException("The post Id does not exist");
    }

    // Update the properties
    post.title = patchPostDto.title ?? post.title;
    post.content = patchPostDto.content ?? post.content;
    post.status = patchPostDto.status ?? post.status;
    post.postType = patchPostDto.postType ?? post.postType;
    post.slug = patchPostDto.slug ?? post.slug;
    post.featuredImageUrl =
      patchPostDto.featuredImageUrl ?? post.featuredImageUrl;
    post.publishOn = patchPostDto.publishOn ?? post.publishOn;

    // Assign the new tags
    post.tags = tags;

    // Save the post and return
    try {
      await this.postsRepository.save(post);
    } catch (error) {
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the database",
        }
      );
    }
    return post;
  }

  public async delete(id: number) {
    // Deleting the post
    await this.postsRepository.delete(id);
    // confirmation
    return { deleted: true, id };
  }
}
```

`src/tags/tags.module.ts`

```typescript
import { Module } from "@nestjs/common";
import { Tag } from "./tag.entity";
import { TagsController } from "./tags.controller";
import { TagsService } from "./providers/tags.service";
import { TypeOrmModule } from "@nestjs/typeorm";

@Module({
  controllers: [TagsController],
  imports: [TypeOrmModule.forFeature([Tag])],
  providers: [TagsService],
  exports: [TagsService],
})
export class TagsModule {}
```

`src/tags/tags.controller.ts`

```typescript
import {
  Body,
  Controller,
  Delete,
  ParseIntPipe,
  Post,
  Query,
} from "@nestjs/common";
import { CreateTagDto } from "./dtos/create-tag.dto";
import { TagsService } from "./providers/tags.service";

@Controller("tags")
export class TagsController {
  constructor(
    /**
     * Inject  tagsService
     */
    private readonly tagsService: TagsService
  ) {}
  @Post()
  public create(@Body() createTagDto: CreateTagDto) {
    return this.tagsService.create(createTagDto);
  }

  @Delete()
  public delete(@Query("id", ParseIntPipe) id: number) {
    return this.tagsService.delete(id);
  }

  @Delete("soft-delete")
  public softDelete(@Query("id", ParseIntPipe) id: number) {
    return this.tagsService.softRemove(id);
  }
}
```

`src/tags/providers/tags.service.ts`

```typescript
import { In, Repository } from "typeorm";
import { CreateTagDto } from "../dtos/create-tag.dto";
import { Injectable } from "@nestjs/common";
import { Tag } from "../tag.entity";
import { InjectRepository } from "@nestjs/typeorm";

@Injectable()
export class TagsService {
  constructor(
    /**
     * Inject tagsRepository
     */
    @InjectRepository(Tag)
    private readonly tagsRepository: Repository<Tag>
  ) {}

  public async create(createTagDto: CreateTagDto) {
    let tag = this.tagsRepository.create(createTagDto);
    return await this.tagsRepository.save(tag);
  }

  public async findMultipleTags(tags: number[]) {
    let results = await this.tagsRepository.find({
      where: {
        id: In(tags),
      },
    });

    return results;
  }

  public async delete(id: number) {
    await this.tagsRepository.delete(id);

    return {
      deleted: true,
      id,
    };
  }

  public async softRemove(id: number) {
    await this.tagsRepository.softDelete(id);

    return {
      softDeleted: true,
      id,
    };
  }
}
```

`src/tags/tag.entity.ts`

```typescript
import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  ManyToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from "typeorm";

import { Post } from "src/posts/post.entity";

@Entity()
export class Tag {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: "varchar",
    length: 256,
    nullable: false,
    unique: true,
  })
  name: string;

  @Column({
    type: "varchar",
    length: 512,
    nullable: false,
    unique: true,
  })
  slug: string;

  @Column({
    type: "text",
    nullable: true,
  })
  description: string;

  @Column({
    type: "text",
    nullable: true,
  })
  schema: string;

  @Column({
    type: "varchar",
    length: 1024,
    nullable: true,
  })
  featuredImage: string;

  @ManyToMany(() => Post, (post) => post.tags, {
    onDelete: "CASCADE",
  })
  posts: Post[];

  // https://orkhan.gitbook.io/typeorm/docs/decorator-reference
  @CreateDateColumn()
  createDate: Date;

  @UpdateDateColumn()
  updateDate: Date;

  // Add this decorartor and column enables soft delete
  @DeleteDateColumn()
  deletedAt: Date;
}
```

`src/tags/dtos/create-tag.dto.ts`

```typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsJSON,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsUrl,
  Matches,
  MaxLength,
  MinLength,
} from "class-validator";

export class CreateTagDto {
  @ApiProperty()
  @IsString()
  @MinLength(3)
  @IsNotEmpty()
  @MaxLength(256)
  name: string;

  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {
    message:
      'A slug should be all small letters and uses only "-" and without spaces. For example "my-url"',
  })
  @MaxLength(512)
  slug: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsJSON()
  schema: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsUrl()
  @MaxLength(1024)
  featuredImage: string;
}
```

`src/users/users.module.ts`

```typescript
import { Module, forwardRef } from "@nestjs/common";

import { AuthModule } from "src/auth/auth.module";
import { ConfigModule } from "@nestjs/config";
import { TypeOrmModule } from "@nestjs/typeorm";
import { User } from "./user.entity";
import { UsersController } from "./users.controller";
import { UsersCreateManyProvider } from "./providers/users-create-many.provider";
import { UsersService } from "./providers/users.service";
import profileConfig from "./config/profile.config";

@Module({
  controllers: [UsersController],
  providers: [UsersService, UsersCreateManyProvider],
  exports: [UsersService],
  imports: [
    TypeOrmModule.forFeature([User]),
    ConfigModule.forFeature(profileConfig),
    forwardRef(() => AuthModule),
  ],
})
export class UsersModule {}
```

`src/users/users.controller.ts`

```typescript
import {
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  Put,
  Query,
  Body,
  Headers,
  Ip,
  ParseIntPipe,
  DefaultValuePipe,
  ValidationPipe,
} from "@nestjs/common";
import { CreateUserDto } from "./dtos/create-user.dto";
import { GetUsersParamDto } from "./dtos/get-users-param.dto";
import { PatchUserDto } from "./dtos/patch-user.dto";
import { UsersService } from "./providers/users.service";
import { ApiTags, ApiQuery, ApiOperation, ApiResponse } from "@nestjs/swagger";
import { CreateManyUsersDto } from "./dtos/create-many-users.dto";

@Controller("users")
@ApiTags("Users")
export class UsersController {
  constructor(
    // Injecting Users Service
    private readonly usersService: UsersService
  ) {}

  @Get("/:id?")
  @ApiOperation({
    summary: "Fetches a list of registered users on the application",
  })
  @ApiResponse({
    status: 200,
    description: "Users fetched successfully based on the query",
  })
  @ApiQuery({
    name: "limit",
    type: "number",
    required: false,
    description: "The number of entries returned per query",
    example: 10,
  })
  @ApiQuery({
    name: "page",
    type: "number",
    required: false,
    description:
      "The position of the page number that you want the API to return",
    example: 1,
  })
  public getUsers(
    @Param() getUserParamDto: GetUsersParamDto,
    @Query("limit", new DefaultValuePipe(10), ParseIntPipe) limit: number,
    @Query("page", new DefaultValuePipe(1), ParseIntPipe) page: number
  ) {
    return this.usersService.findAll(getUserParamDto, limit, page);
  }

  @Post()
  public createUsers(@Body() createUserDto: CreateUserDto) {
    return this.usersService.createUser(createUserDto);
  }

  @Post("create-many")
  public createManyUsers(@Body() createManyUsersDto: CreateManyUsersDto) {
    return this.usersService.createMany(createManyUsersDto);
  }

  @Patch()
  public patchUser(@Body() patchUserDto: PatchUserDto) {
    return patchUserDto;
  }
}
```

`src/users/providers/users.service.ts`

```typescript
import { CreateUserDto } from "./../dtos/create-user.dto";
import { DataSource, Repository } from "typeorm";
import { GetUsersParamDto } from "../dtos/get-users-param.dto";
import {
  BadRequestException,
  HttpException,
  HttpStatus,
  Inject,
  Injectable,
  RequestTimeoutException,
} from "@nestjs/common";
import { User } from "../user.entity";
import { InjectRepository } from "@nestjs/typeorm";
import { ConfigService, ConfigType } from "@nestjs/config";
import profileConfig from "../config/profile.config";
import { UsersCreateManyProvider } from "./users-create-many.provider";
import { CreateManyUsersDto } from "../dtos/create-many-users.dto";

/**
 * Controller class for '/users' API endpoint
 */
@Injectable()
export class UsersService {
  constructor(
    /**
     * Injecting usersRepository
     */
    @InjectRepository(User)
    private usersRepository: Repository<User>,

    @Inject(profileConfig.KEY)
    private readonly profileConfiguration: ConfigType<typeof profileConfig>,

    /**
     * Inject UsersCreateMany provider
     */
    private readonly usersCreateManyProvider: UsersCreateManyProvider
  ) {}

  public async createUser(createUserDto: CreateUserDto) {
    let existingUser = undefined;

    try {
      // Check is user exists with same email
      existingUser = await this.usersRepository.findOne({
        where: { email: createUserDto.email },
      });
    } catch (error) {
      // Might save the details of the exception
      // Information which is sensitive
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the database",
        }
      );
    }

    // Handle exception
    if (existingUser) {
      throw new BadRequestException(
        "The user already exists, please check your email."
      );
    }

    // Create a new user
    let newUser = this.usersRepository.create(createUserDto);

    try {
      newUser = await this.usersRepository.save(newUser);
    } catch (error) {
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the the datbase",
        }
      );
    }

    return newUser;
  }

  /**
   * Public method responsible for handling GET request for '/users' endpoint
   */
  public findAll(
    getUserParamDto: GetUsersParamDto,
    limt: number,
    page: number
  ) {
    throw new HttpException(
      {
        status: HttpStatus.MOVED_PERMANENTLY,
        error: "The API endpoint does not exist",
        fileName: "users.service.ts",
        lineNumber: 88,
      },
      HttpStatus.MOVED_PERMANENTLY,
      {
        cause: new Error(),
        description: "Occured because the API endpoint was permanently moved",
      }
    );
  }

  /**
   * Public method used to find one user using the ID of the user
   */
  public async findOneById(id: number) {
    let user = undefined;

    try {
      user = await this.usersRepository.findOneBy({
        id,
      });
    } catch (error) {
      throw new RequestTimeoutException(
        "Unable to process your request at the moment please try later",
        {
          description: "Error connecting to the the datbase",
        }
      );
    }

    /**
     * Handle the user does not exist
     */
    if (!user) {
      throw new BadRequestException("The user id does not exist");
    }

    return user;
  }

  public async createMany(createManyUsersDto: CreateManyUsersDto) {
    return await this.usersCreateManyProvider.createMany(createManyUsersDto);
  }
}
```

`src/users/providers/users-create-many.provider.ts`

```typescript
import {
  ConflictException,
  Injectable,
  RequestTimeoutException,
} from "@nestjs/common";

import { CreateManyUsersDto } from "../dtos/create-many-users.dto";
import { DataSource } from "typeorm";
import { User } from "../user.entity";

@Injectable()
export class UsersCreateManyProvider {
  constructor(
    /**
     * Inject the datasource
     */
    private dataSource: DataSource
  ) {}

  public async createMany(createManyUsersDto: CreateManyUsersDto) {
    let newUsers: User[] = [];

    // Create Query Runner Instance
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      // Connect the query ryunner to the datasource
      await queryRunner.connect();
      // Start the transaction
      await queryRunner.startTransaction();
    } catch (error) {
      throw new RequestTimeoutException("Could not connect to the database");
    }

    try {
      for (let user of createManyUsersDto.users) {
        let newUser = queryRunner.manager.create(User, user);
        let result = await queryRunner.manager.save(newUser);
        newUsers.push(result);
      }
      await queryRunner.commitTransaction();
    } catch (error) {
      // since we have errors lets rollback the changes we made
      await queryRunner.rollbackTransaction();
      throw new ConflictException("Could not complete the transaction", {
        description: String(error),
      });
    } finally {
      try {
        // you need to release a queryRunner which was manually instantiated
        await queryRunner.release();
      } catch (error) {
        throw new RequestTimeoutException(
          "Could not release the query runner connection"
        );
      }
    }

    return newUsers;
  }
}
```

`src/users/user.entity.ts`

```typescript
import { Column, Entity, OneToMany, PrimaryGeneratedColumn } from "typeorm";

import { Post } from "src/posts/post.entity";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: "varchar",
    length: 96,
    nullable: false,
  })
  firstName: string;

  @Column({
    type: "varchar",
    length: 96,
    nullable: true,
  })
  lastName: string;

  @Column({
    type: "varchar",
    length: 96,
    nullable: false,
    unique: true,
  })
  email: string;

  @Column({
    type: "varchar",
    length: 96,
    nullable: false,
  })
  password: string;

  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];
}
```

`src/users/config/profile.config.ts`

```typescript
import { registerAs } from "@nestjs/config";

export default registerAs("profileConfig", () => ({
  apiKey: process.env.PROFILE_API_KEY,
}));
```

`src/users/dtos/create-user.dto.ts`

```typescript
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  Matches,
  MaxLength,
  MinLength,
} from "class-validator";

export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  @MaxLength(96)
  firstName: string;

  @IsString()
  @IsOptional()
  @MinLength(3)
  @MaxLength(96)
  lastName?: string;

  @IsEmail()
  @IsNotEmpty()
  @MaxLength(96)
  email: string;

  @IsString()
  @IsNotEmpty()
  @MinLength(8)
  @MaxLength(96)
  @Matches(/^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$/, {
    message:
      "Minimum eight characters, at least one letter, one number and one special character",
  })
  password: string;
}
```

`src/users/dtos/get-users-param.dto.ts`

```typescript
import { IsInt, IsOptional } from "class-validator";

import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";

export class GetUsersParamDto {
  @ApiPropertyOptional({
    description: "Get user with a specific id",
    example: 1234,
  })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  id?: number;
}
```

`src/users/dtos/patch-user.dto.ts`

```typescript
import { CreateUserDto } from "./create-user.dto";
import { PartialType } from "@nestjs/mapped-types";

export class PatchUserDto extends PartialType(CreateUserDto) {}
```

`src/users/dtos/create-many-users.dto.ts`

```typescript
import { IsArray, IsNotEmpty, ValidateNested } from "class-validator";

import { ApiProperty } from "@nestjs/swagger";
import { CreateUserDto } from "./create-user.dto";
import { Type } from "class-transformer";

export class CreateManyUsersDto {
  @ApiProperty({
    type: "array",
    required: true,
    items: {
      type: "User",
    },
  })
  @IsNotEmpty()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateUserDto)
  users: CreateUserDto[];
}
```
