### Общий контекст

В предыдущем видео был создан DTO `CreatePostDto` без валидации. В этом видео автор добавляет **декораторы валидации** из библиотеки `class-validator` к каждому свойству DTO, чтобы обеспечить корректность входящих данных.

---

### Детальное объяснение по разделам:

#### 1. Введение в валидацию и библиотеку class-validator

**Что такое валидация и зачем она нужна?**

- **Валидация** — это процесс проверки, что входящие данные соответствуют определенным правилам (обязательные поля, минимальная длина, корректный формат и т.д.).
- **Библиотека `class-validator`** — это стандартная библиотека для NestJS, которая использует **декораторы** для добавления правил валидации к свойствам классов (DTO).

**Важное замечание:** Все декораторы валидации (`IsString`, `IsNotEmpty`, `MinLength` и др.) импортируются из пакета `class-validator`.

---

#### 2. Валидация свойства `title`

```typescript
@IsString()
@IsNotEmpty()
@MinLength(3)
title: string;
```

**Объяснение декораторов:**

- **`@IsString()`** — проверяет, что значение является строкой. Если пришло число или boolean — будет ошибка валидации.
- **`@IsNotEmpty()`** — проверяет, что строка не пустая. Это строже, чем `@IsOptional()`. Пустая строка `''` не пройдет валидацию.
- **`@MinLength(3)`** — проверяет, что длина строки не менее 3 символов. Это предотвращает создание постов с слишком короткими заголовками.

**Логика валидации:** Все три проверки должны пройти успешно. Если какая-то одна fails — весь запрос будет отклонен с ошибкой 400 Bad Request.

---

#### 3. Валидация enum'ов (`postType` и `status`)

```typescript
@IsEnum(PostType)
@IsNotEmpty()
postType: PostType;

@IsEnum(PostStatus)
@IsNotEmpty()
status: PostStatus;
```

**Что делает `@IsEnum()`:**

- **`@IsEnum(PostType)`** — проверяет, что значение принадлежит к перечислению `PostType`. Допустимые значения: `PostType.Post`, `PostType.Page`, `PostType.Story`, `PostType.Series`.
- **Зачем это нужно:** Предотвращает передачу невалидных значений. Если клиент попробует отправить `postType: 'invalid_value'`, валидация не пройдет.
- **`@IsNotEmpty()`** добавлен, потому что эти поля обязательные.

---

#### 4. Валидация `slug` с регулярным выражением

```typescript
@IsString()
@IsNotEmpty()
@Matches(/^[a-z0-9-]+$/, {
  message: 'A slug should be all small letters and uses only hyphen and without spaces. Example: my-post-title-123'
})
slug: string;
```

**Объяснение:**

- **`@Matches(/^[a-z0-9-]+$/)`** — проверяет, что строка соответствует регулярному выражению:
  - `^` — начало строки
  - `[a-z0-9-]+` — один или более символов: маленькие буквы (a-z), цифры (0-9) или дефис (-)
  - `$` — конец строки
- **Кастомное сообщение:** Вторым параметром передается объект с полем `message`. Это сообщение будет отправлено клиенту в случае ошибки валидации, чтобы он понимал, какой формат данных ожидается.

---

#### 5. Валидация опциональных полей

**Для опциональных полей используется комбинация декораторов:**

```typescript
@IsString()
@IsOptional()
content?: string;

@IsUrl()
@IsOptional()
featuredImage?: string;
```

**Что такое `@IsOptional()`:**

- Указывает, что поле **не обязательное**. Если поле отсутствует в запросе — валидация пройдет.
- **ВАЖНО:** Если поле присутствует, но с невалидным значением (например, `featuredImage: 'not-a-url'`) — валидация НЕ пройдет.
- `@IsOptional()` всегда используется в комбинации с другими декораторами валидации.

---

#### 6. Специальные валидаторы для сложных случаев

**Валидация JSON строки для `schema`:**

```typescript
@IsJSON()
@IsOptional()
schema?: string;
```

**Что делает `@IsJSON()`:**

- Проверяет, что строка содержит валидный JSON. Например: `'{"key": "value"}'` пройдет валидацию, а `'not-json'` — нет.
- Это полезно, когда вы ожидаете сериализованный JSON объект в строковом формате.

**Валидация даты для `publishedOn`:**

```typescript
@IsISO8601()
@IsOptional()
publishedOn?: Date;
```

**Что делает `@IsISO8601()`:**

- Проверяет, что строка соответствует стандарту ISO 8601 для дат (например: `'2023-10-05T14:30:00.000Z'`).
- Это более надежно, чем `@IsDate()`, так как проверяет конкретный формат, commonly используемый в API.

---

#### 7. Валидация массивов — самая сложная часть

```typescript
@IsOptional()
@IsArray()
@IsString({ each: true })
@MinLength(3, { each: true })
tags?: string[];
```

**Пошаговое объяснение:**

1. **`@IsOptional()`** — массив tags не обязателен
2. **`@IsArray()`** — если поле присутствует, оно должно быть массивом
3. **`@IsString({ each: true })`** — параметр `{ each: true }` указывает, что валидация применяется к **каждому элементу** массива. Каждый тег должен быть строкой.
4. **`@MinLength(3, { each: true })`** — снова `{ each: true }` означает, что минимальная длина проверяется для каждого элемента массива. Каждый тег должен быть не короче 3 символов.

**Примеры валидации:**

- `tags: ['tech', 'programming']` — ✅ пройдет
- `tags: ['js']` — ❌ не пройдет (длина 'js' меньше 3)
- `tags: [123, 'tech']` — ❌ не пройдет (123 не строка)
- `tags: 'not-an-array'` — ❌ не пройдет (не массив)

---

### Итог проделанной работы:

1. **Установлены базовые правила валидации** для всех свойств DTO:

   - Обязательные vs опциональные поля
   - Проверки типов данных (string, array, enum)
   - Проверки формата (URL, JSON, ISO date, regex для slug)

2. **Использованы различные стратегии валидации:**

   - Простые проверки (`@IsString()`, `@IsNotEmpty()`)
   - Проверки формата (`@Matches()`, `@IsUrl()`, `@IsJSON()`)
   - Валидация массивов с `{ each: true }`
   - Валидация enum'ов

3. **Обеспечена информативность ошибок** через кастомные сообщения

4. **Оставлена задача на будущее:** Валидация nested объекта `metaOptions` будет рассмотрена в следующем видео, где автор покажет работу с вложенными DTO.

**Результат:** Теперь ваш API endpoint будет автоматически отклонять некорректные запросы и возвращать детальные ошибки валидации, что значительно повышает надежность вашего приложения.
