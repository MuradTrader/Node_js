### Детальное объяснение работы с буферами по тексту автора курса с сравнением Node.js и Go

#### Основные концепции из текста автора:

1. **Создание буфера**:

   - `Buffer.alloc(4)` выделяет 4 байта (32 бита) памяти
   - Память инициализируется нулями: `[0x00, 0x00, 0x00, 0x00]`
   - Буфер ведет себя как массив с индексацией (от 0 до size-1)

2. **Запись данных**:

   - Прямое присваивание через индексы: `buffer[0] = 0xf4`
   - Каждый элемент хранит ровно 1 байт (диапазон 0-255)
   - Пример записи:
     ```javascript
     memoryContainer[0] = 0x48; // 'H' в ASCII
     memoryContainer[1] = 0x69; // 'i' в ASCII
     ```

3. **Чтение данных**:

   - `console.log(buffer)` выводит HEX-представление
   - `console.log(buffer[0])` выводит DECIMAL-значение элемента
   - Диапазон значений: 0-255 (максимум для 8 бит)

4. **Преобразование в строку**:

   - `buffer.toString('utf-8')` декодирует бинарные данные в текст
   - Важность указания кодировки (разные кодировки → разный результат)

5. **Альтернативные методы создания**:
   - `Buffer.from([0x48, 0x69, 0x21])`
   - `Buffer.from("486921", 'hex')`
   - `Buffer.from("Hi!", 'utf-8')`

#### Сравнение Node.js и Go:

| Концепция               | Node.js (по тексту автора)               | Go (аналог)                               |
| ----------------------- | ---------------------------------------- | ----------------------------------------- |
| **Создание буфера**     | `Buffer.alloc(4)`                        | `buf := make([]byte, 4)`                  |
| **Запись данных**       | `buf[0] = 0x48`                          | `buf[0] = 0x48`                           |
| **Чтение элемента**     | `console.log(buf[0])` → 72               | `fmt.Println(buf[0])` → 72                |
| **Вывод всего буфера**  | `console.log(buf)` → `<Buffer 48 69 21>` | `fmt.Printf("% x", buf)` → `48 69 21`     |
| **Размер элемента**     | Фиксировано 1 байт                       | `byte` = 1 байт (псевдоним uint8)         |
| **Диапазон значений**   | 0-255                                    | 0-255 (тип byte)                          |
| **В HEX-строку**        | `buf.toString('hex')` → "486921"         | `hex.EncodeToString(buf)` → "486921"      |
| **Из HEX-строки**       | `Buffer.from("486921", 'hex')`           | `hex.DecodeString("486921")`              |
| **В UTF-8 строку**      | `buf.toString('utf-8')` → "Hi!"          | `string(buf)` (если buf содержит UTF-8)   |
| **Из строки (UTF-8)**   | `Buffer.from("Hi!", 'utf-8')`            | `[]byte("Hi!")`                           |
| **Неизменяемый размер** | Да                                       | Слайсы могут менять размер через `append` |

#### Практические примеры из текста:

**1. Создание и заполнение буфера в Node.js (аналог в Go):**

```javascript
// Node.js
const buffer = require("buffer");
const mem = Buffer.alloc(3);
mem[0] = 0x48; // 'H'
mem[1] = 0x69; // 'i'
mem[2] = 0x21; // '!'
console.log(mem.toString("utf-8")); // "Hi!"
```

```go
// Go
package main

import "fmt"

func main() {
    buf := make([]byte, 3)
    buf[0] = 0x48 // 'H'
    buf[1] = 0x69 // 'i'
    buf[2] = 0x21 // '!'
    fmt.Println(string(buf)) // "Hi!"
}
```

**2. Декодирование бинарных данных (вызов автора):**

```javascript
// Node.js решение вызова
const binBuffer = Buffer.from([0x48, 0x69, 0x21]);
console.log(binBuffer.toString("utf-8")); // "Hi!"
```

```go
// Go решение вызова
package main

import (
    "encoding/hex"
    "fmt"
)

func main() {
    data, _ := hex.DecodeString("486921")
    fmt.Println(string(data)) // "Hi!"
}
```

**3. Важные предупреждения автора:**

- **Точный размер**: При выделении буфера указывать ровно столько байт, сколько нужно
- **Диапазон значений**: 0-255 для каждого элемента (в Go это обеспечивает тип `byte`)
- **Кодировки**: Всегда явно указывать кодировку при преобразовании бинарных данных в строку
- **Эффективность**: Буферы работают напрямую с памятью, что критично для I/O операций

#### Ключевые термины:

- **Code Point**: Числовое представление символа (например, 115 для 's')
- **HEX vs BINARY**: `0x48` (HEX) = `01001000` (BINARY) = 72 (DECIMAL)
- **UTF-8**: Кодировка переменной длины (1-4 байта на символ)

Автор подчеркивает: **Буферы - это низкоуровневый инструмент для работы с "сырой" памятью**, одинаково важный в Node.js и Go. В следующей части курса - мониторинг использования памяти при работе с большими буферами.
