### Погружение в Пул Потоков в Libuv (Thread pool)

Поток это контейнер в котором можно запустить код.
Libuv использует пул потоков чтобы выполнять асинхронные задачи к примеру чтение файлов, запрос к API, и тд.
Когда движок V8 в стэке встречает асинхронную задачу допустим это чтение файлов, он передает эту задачу в Libuv а это фаза Ожидания (Poll), и Libuv если находит свободный Пул потоков, он выполняет данную задачу в этом потоке.

Этот пул потоков (Thread pool) делает запрос к операционной системе, затем файл читается, а затем пул потоков возвращает поток обратно и этот поток становится свободным.
Пока файл читается этот поток полностью занят.
Когда файл будет полностью прочитан, пул потоков полностью освободится и будет готов к выполнению других операций.

В NodeJS размер пул потоков (Thread pool) по умолчанию равен четырем.
Допустим если мы одновременно сделаем 5 вызовов для чтение файлов к операционной системе, один файл занимает один поток, другой файл занимает еще другой один поток, и таким образом 4 файлов занимают 4 пул потоков, и еще один пятый файл приходит для чтение файлов, теперь ему придется ждать пока не освободится один из потоков.
Этот пятый файл не будет обработан немедленно.

Все тяжелые операции такие как чтение файлов fs, crypto и тд.
Будут обработаны через пул потоков (Thread pool).

#### NodeJS одно поточный или много поточный ?

Когда в NodeJS код выполняется синхронно, он одно поточный и этот код выполняется в основном потоке в движке V8 стэке вызовов.
Но когда код выполняется асинхронно, NodeJS становится много поточным с помощью Libuv, потому что Libuv может использовать пул потоков (Thread pool).

Допустим у нас в коде выполняются одно временно 4 асинхронных задач, допустим криптографические задачи.
Они будут выполнятся одно временно потому что они выполняются в четырех потоках.
Если один из этих потоков первым вернет ответ и переместит функция обратного вызова в очереди (Callback Queues), он и будет выполнен первым в стэке вызовов.
Но все эти 4 задачи выполняются одно временно в пул потоках.

Но если мы добавим еще одну пятую асинхронную криптографическую задачу, ему придется ждать пока не освободится один из четырех потоков.
Таким образом данная пятая задача будет выполнен самым последним, потому что данная пятая задача еще не находится в пул потоках и не обрабатывается.

Также в NodeJS мы можем изменить размер пул потоков (Thread pool).
Таким образом:

```javascript
process.env.UV_THREADPOOL_SIZE = 2;
process.env.UV_THREADPOOL_SIZE = 10;
process.env.UV_THREADPOOL_SIZE = 100;
process.env.UV_THREADPOOL_SIZE = 1000;
```
