### Погружение в Libuv и Event Loop (Цикл событий)

В NodeJS есть две основные части:
1 - Движок V8 он работает в основном потоке.
2 - Это Libuv.

#### Внутри Libuv есть три основных компонента

1 - Это Event Loop (Цикл обработки событий)
2 - Очередь функций обратных вызовов (Callback Queues)
3 - Пулл потоков (Thread Pool)

#### Что происходит когда асинхронная задача загружается в Libuv?

Предположим что движок V8 передал задачу чтение файлов в Libuv.
Libuv делает запрос к операционной системе, он читает файл и получает данный обратно.
И когда данный будут получены, Libuv должна будет передать функция обратного вызова
движку V8 в стэк вызовов.

Кто отправить эту функцию обратного вызова в стэк вызовов?
Как она туда попадет ?
Предположим что задача чтение файлов быстро выполнено и движок V8 все еще занят
выполнением синхронного кода.
Теперь функция обратного вызова должна ждать в очереди (Callback Queues),
так как движок V8 занят выполнением синхронного кода.

Предположим что одновременно выполняется Таймер, и таймер заканчивается и возвращается функция обратного вызова.
Оба функции обратного вызова чтение файла и таймера готовы и должны выполняться одновременно.
Чтобы справиться с этим Libuv поддерживает очереди обратных вызовов (Callback Queues).
Так что для таймеров есть отдельный очередь, также есть отдельный очередь для вызова API через сеть.

Когда стэк вызовов пуст в нем можно поместить только то что находится в очереди обратных вызовов.

#### Теперь Libuv попадает в цикл событий (Event Loop).

В чем заключается работы цикл событий (Event Loop)?
Его единственная задача проверять стэк вызовов и очередь обратных вызовов.
Когда стэк вызовов пусть Libuv берет функция обратного вызова из очереди обратных вызовов, и помещает в стэк вызовов и функция обратного вызова выполняется в стэке вызовов, то есть создается контекст выполнения функции обратного вызова и выполняется код внутри него.

Цикл обработки событий (Event Loop) должен что то выбрать из очереди обратных вызовов (Callback Queues).

Как он это сделает ?
Какую функцию обратного вызова запустить первым ?
Функция чтение файлов или функция таймера или функция вызова API ?
Существует определенный механизм как это происходит.

#### Как работает цикл обработки событий (Event Loop)?

У цикл обработки событий есть определенные фазы.
Цикл обработки событий работает по кругу.

Внутри цикла обработки событий есть много фаз,
но есть четыре основных фаз:
1 - Это фаза Таймера (Timer)
2 - Это фаза ожидания (Poll)
3 - Это фаза проверки (Check)
4 - Это фаза завершения (Close)

Все они выполняются одна за другой.
Timer -> Poll -> Check -> Close
Close -> Timer -> Poll -> Check -> Close
и так по кругу.

В первой фазе, фаза Таймера (Timer) выполняются все функции обратного вызова
setTimeout и setInterval.
Если в очереди обратных вызовов стоит функция обратного вызова Таймера, Event Loop берет функцию Таймера в качестве приоритета.

Затем Event Loop перейдет в фазу Ожидания (Poll).
В данной фазе выполняются все функции обратного вызова, связанные с вводом выводом.
Допустим чтение файла (fs), или вызов API через сеть (http) запрос (Get).

Затем Event Loop перейдет в фазу Проверки (Check).
В данной фазе выполняется функция обратного вызова setImmediate.

Затем Event Loop перейдет в фазу Завершения (Close).
Здесь выполняются все операции завершении, допусти мы открыли socket и хотим закрыть socket, обработка socket на этапе завершении будет происходит на этой фазе.

Таким образом по кругу работает Event Loop при этом проверяя пуст ли стэк вызовов.

#### Внутренний цикл (Process nextTick() и Promise Callback)

Перед каждым этапом цикл обработки событий (Event Loop) будет происходит внутренний цикл, то есть перед каждой основной фазой цикла событий будет происходит внутренний цикл а именно будут выполняться функции обратных вызовов nextTick() и Promise.
1 - nextTick -> 2 - Promise

Event Loop проверит перед каждой основной фазой, есть ли функции обратных вызовов nextTick затем функции обратных вызовов Promise в (Callback Queues).

Если в очереди обратных вызовов (Callback Queues) нет функции обратных вызовов nextTick и Promise, то Event Loop перейдет к основной фазе.
Но пока, если есть функции обратных вызовов nextTick и Promise в Callback Queues,
то ни одна основная фаза не будет выполнено.

#### 1 - Пример

```javascript
process.nextTick(cb);

Promise.resolve(cb);

setTimeout(cb, 0);

setImmediate(cb);

fs.readFile("./file.txt", cb);

https.get("URL", cb);
```

Допустим все эти асинхронные задачи выполнены и все функции обратного вызова (cb) ждут в очереди обратных вызовов (Callback Queues).

1 - Запустится Event Loop и выполнит функция обратного вызова process.nextTick().

2 - Затем будет выполнено функция обратного вызова Promise.resolve().

3 - Затем Event Loop перейдет к основной фазе Таймера setTimeout(), и будет выполнен.

4 - Затем Event Loop прежде чем перейти к основной фазе Ожидания (Poll), он снова проверит есть ли что то в Callback Queues из nextTick() и Promise, но в нашем примере нет ничего из nextTick() и Promise.

5 - Event Loop перейдет к основной фазе Ожидания (Poll), и выполнит функции обратных вызовов (cb), fs.readFile() и https.get().

6 - Затем Event Loop прежде чем перейти к основной фазе Проверки (Check), он снова проверит есть ли что то в Callback Queues из nextTick() и Promise, но в нашем примере нет ничего из nextTick() и Promise.

7 - Event Loop перейдет к основной фазе Проверки (Check), и выполнит функция обратного вызова (cb), setImmediate().

8 - Затем Event Loop прежде чем перейти к основной фазе Закрытия (Close), он снова проверит есть ли что то в Callback Queues из nextTick() и Promise, но в нашем примере нет ничего из nextTick() и Promise.

9 - Event Loop перейдет к основной фазе Закрытия (Close), но в нашем примере нет операции по закрытию такие сокеты (socket).

10 - Затем Event Loop прежде чем перейти к основной фазе Таймера (Timer), он снова проверит есть ли что то в Callback Queues из nextTick() и Promise, но в нашем примере нет ничего из nextTick() и Promise.
И таким образом по кругу, будет выполнятся цикл снова и снова.

#### 2 - Пример

```javascript
const a = 100;

setImmediate(() => console.log("setImmediate"));

fs.readFile("./file.txt", "utf8", () => {
  console.log("File Reading CB");
});

setTimeout(() => console.log("Timer expired"), 0);

function printA() {
  console.log("a = ", a);
}

printA();
console.log("Last line of the file.");

// console
/* 
1) a = 100
2) Last line of the file.
3) Timer expired
4) setImmediate
5) File Reading CB -> Он последний потому что когда Event Loop проверил фазу Poll после фазы Timer, файл еще не был прочитан и функция обратного вызова не было перемещена в очередь (Callback Queues)
*/
```

#### 3 - Пример

```javascript
setImmediate(() => console.log("setImmediate"));

Promise.resolve("Promise").then(console.log);

fs.readFile("./file.txt", "utf8", () => {
  console.log("File Reading CB");
});

setTimeout(() => console.log("Timer expired"), 0);

process.nextTick(() => console.log("process.nextTick"));

function printA() {
  console.log("a = ", a);
}

printA();
console.log("Last line of the file.");

// console
/* 
1) a = 100
2) Last line of the file.
3) process.nextTick
4) Promise
5) Timer expired
6) setImmediate
7) File Reading CB -> Он последний потому что когда Event Loop проверил фазу Poll после фазы Timer, файл еще не был прочитан и функция обратного вызова не было перемещена в очередь (Callback Queues)
*/
```

#### Ожидание Event Loop в фазе Ожидания (Poll)

Допусти у нас стэк вызовов пуст, и когда наши асинхронные задачи еще не выполнились и ихние функции обратного вызова еще не помещены в очередь Callback Queues.

Тогда что будет делать Event Loop ?
Он будет ждать в фазе Ожидание (Poll).
Он будет ждать пока не произойдет какой нибудь событий в фазе Ожидание (Poll).
Таким образом Event Loop начинает свой цикл с фазы Ожидание (Poll).
Poll -> Check -> Close -> Timer

Еще нужно понимать что цикл событий (Event Loop) в браузере не такой как в NodeJS Libuv. Цикл событий (Event Loop) в браузере, он как обычно будет работать снова и снова по кругу.

#### 4 - Пример

```javascript
setImmediate(() => console.log("setImmediate"));

setTimeout(() => console.log("Timer expired"), 0);

Promise.resolve("Promise").then(console.log);

fs.readFile("./file.txt", "utf8", () => {
  setTimeout(() => console.log("2nd timer"), 0);

  process.nextTick(() => console.log("2nd nextTick"));

  setImmediate(() => console.log("2nd setImmediate"));

  console.log("File Reading CB");
});

process.nextTick(() => console.log("process.nextTick"));

console.log("Last line of the file.");

// console
/* 
1) Last line of the file.
2) process.nextTick
3) Promise
4) Timer expired
5) setImmediate
6) File Reading CB
7) 2nd nextTick
8) 2nd setImmediate -> так как Event Loop ждет в фазе ожидания (Poll), и начинает свой цикл с фазы ожидания (Poll) а не с фазы Таймера (Timer), а после фазы ожидание Poll идет фаза Проверки (Check) а не фаза Таймера (Timer). 
9) 2nd timer
*/
```
