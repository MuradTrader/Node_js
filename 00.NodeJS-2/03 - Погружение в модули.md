### Это глубокое погружение в модули и их работу.

Весь код который находится внутри какого то модуля когда мы его импортируем JS
оборачивает весь код внутри этого файла в немедленно вызываемую функцию, и данная функция сразу же вызывается и код выполняется внутри этого модуля.
Если код обернуть внутри этой функции - это означает что это не зависимый код.

Откуда берется module.exports ?
module.export={} это пустой объект, так вот данный модуль передается
как аргумент в параметр для немедленно вызываемой функции.
Точно также когда мы пишем require для импорта модуля,
точно также require передается в параметр для немедленно вызываемой функции.

Откуда берутся module и require ?
Их предоставляет Nodejs.

То есть весь наш код в любом файле находится внутри немедленно вызываемой функции.
И когда мы пишем require или module мы получаем доступ к ним из параметров
немедленно вызываемой функции, так как наш код находится внутри этой функции.

И когда мы импортируем какой то модуль, require() возвращает нам модуль,
то есть объект так как мы его экспортировали таким образом:
exports.module = { calculateSum }

Когда мы требуем файл (модуль): require().
1 - Разрешение модуля, то есть проверяется является этот файл JS require("./index.js), или утилитам node require("node:util"), или файлом json require("./data.json").
В первом пункте он просто разрешает это.

2 - Загружает содержимое файла, в этих файлах JS, node:util, json,
содержаться данные, когда он получает эти данные.

3 - Он оборачивает их в немедленно вызываемую функцию.

4 - Код будет выполнен и будет возвращен module.exports={}
То есть require() возвращает нам модуль.

5 - Модуль кэшируется.
Например когда несколько файлов требуют один и тот же модуль,
к примеру модуль require("./index.js"), NodeJS его кэширует.
Это значит код require("./index.js") будет выполнен только один раз.
То есть когда один раз выполнен require("./index.js") nodeJS берет этот модуль
из кэша.
NodeJS не будет снова загружать данные в память.

Всякий раз когда мы пишем код в JS этот код напрямую не передается в V8.
Нет, NodeJS оборачивает этот код в немедленно вызываемую функцию,
и только потом передается и затем V8 выполняет его.
