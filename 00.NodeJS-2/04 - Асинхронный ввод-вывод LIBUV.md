### Погружение работы NodeJS за кулисами.

#### JavaScript - это синхронный одно поточный язык.

Это значит что всякий раз когда мы хотим какой то код в JS,
нам нужен движок JS (V8).
Это значит что в JS только один поток, и в этом потоке есть движок JS (V8).
В движке JS (V8) есть стэк вызовов, сборщик мусора, память куча (Heap) и тд.

#### Что если движку JS (8) нужно выполнять асинхронные задачи?

Такие как обращение к файлам, прочитывать баз-данных, вызовы API из сети,
получение таймера и тд.
А движок JS (V8) не умеет ждать, он выполняет все задачи синхронно строка за строкой.
Если асинхронные задачи передавать движку V8 только ему, он не знает как такие задачи выполнять.

#### NodeJS и супер способность.

Вот здесь вступает в игру NodeJS.
Движку JS (V8) нужно супер способности чтобы обратиться к операционной систем и получить какие то файлы.
Также нужен супер способность чтобы обратиться к базе-данных.
Все эти вещи файлы, баз-данных, сеть вызов API, таймер, управляются
операционной системой.

Что это за супер способности?
Эти супер способности дают движку JS (V8) -> NodeJS.
Этим супер героям является Libuv.
Libuv это очень важная часть NodeJS.
Таким образом за асинхронными задачами движок JS (V8) обращается к Libuv,
а он в свою очередь обращается к операционной системе и передает это движку (V8).

#### Пример:

Как работает этот код в NodeJS ?

Весь этот код будет выполнятся в движке V8,
внутри движка V8 есть стэк вызовов, этот код попадает в стэк вызовов.
Создается внутри стэка глобальная контекст выполнение.
И в этом глобальном контексте код выполняется синхронно
строка за строкой сверху вниз.

```
// значение 10 попадает в ячейку в памяти, "a" ссылка на ячейку (10)
var a = 10;

// значение 20 попадает в ячейку в памяти, "b" ссылка на ячейку (20)
var b = 20;

/* Движок V8 -> Libuv зарегистрирует вызов API -> когда придут данные, будет передан функция обратного вызова движку V8 и будет выполнен.
Предположим функция обратного вызова будет (A) */
https.get("https://api.fbi.com", (res) => console.log(res?.secret));

/* Движок V8 переходит к этой строке, он не ждет.
Движок V8 -> Libuv зарегистрирует таймер -> когда таймер закончится, будет передан функция обратного вызова движку V8 и будет выполнен.
Предположим функция обратного вызова будет (B) */
setTimeout(() => {
  console.log("setTimeout");
}, 5000);

/* Движок V8 переходит к этой строке, он не ждет.
Движок V8 -> Libuv зарегистрирует этот файл для чтения -> когда файл прочитан,будет передан функция обратного вызова движку V8 и будет выполнен.
Предположим функция обратного вызова будет (С) */
fs.readFile("./gossip.txt, "utf8", (data) => {
  console.log("File Data", data);
});

/* Теперь движок V8 знает как выполнить данную функцию.
Движок V8 выделит для нее память в ячейке. */
function multiply(x, y) {
  const result = a * b;
  return result;
}

/* Движок V8 при вызове функции, создает новый контекст выполнения в стэке.
Весь код внутри функции будет выполнен.
Когда весь код внутри функции выполнено, возвращает result для "c".
Данная значение result будет помещен в ячейку памяти, "c" ссылка на ячейку.
После выполнении функции и возврата result, все переменные внутри функции будут удалены сборщиком мусора, и сам контекст выполнения функции будет удалено из стэка. */
var c = multiply(a, b);

// Движок V8 выводит значение "c" в консоле.
console.log(c);

```
